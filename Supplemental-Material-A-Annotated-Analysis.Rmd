---
title: "Supplemental Information A: Full Annotated Analysis and Reproducible Code"
subtitle: "Supplemental Material for 'Migration Trajectories [working title]'"
author:
- Jannis Kreienkamp^1,3^
- Kai Epstude^1,3^
- Laura F. Bringmann^1,3^
- Maximilian Agostini^1,3^
- Peter de Jonge^1,3^
- Rei Tendeiro-Monden^2,3^
- ^1^University of Groningen, Department of Psychology
- ^2^Hiroshima University, Graduate School of Advanced Science and Engineering
- ^3^Author order TBD [currently in first name alphabetical order]
- "Author Information:"
- "Correspondence concerning this article should be addressed to Jannis Kreienkamp, Department of Psychology, University of Groningen, Grote Kruisstraat 2/1, 9712 TS Groningen (The Netherlands).  E-mail: j.kreienkamp@rug.nl"
- 'The main manuscript is available at <a href="https://www.doi.org/ToBePublished" target="_blank">doi.org/ToBePublished</a>'
- 'The data repository for this manuscript is available at <a href="https://osf.io/TBA" target="_blank">osf.io/TBA</a>'
- 'The GitHub repository for this manuscript is available at <a href="https://github.com/maskedForPeerReview" target="_blank">github.com/maskedForPeerReview</a>'
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::html_document2:
    fig_caption: yes
    md_extensions: +footnotes
    code_folding: hide
    mathjax: default
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: false
    css: style.css
    includes:
      in_header: "_includes/head-custom-rmd.html" 
editor_options:
  chunk_output_type: console
#bibliography: references.bib
csl: apa.csl
header-includes:
   - \usepackage{amsmath, nccmath}
---

<style type="text/css">
.main-container {
  max-width: 1300px;
  margin-left: auto;
  margin-right: auto;
}
.table {
  margin-left:auto; 
  margin-right:auto;
}
</style>


```{r setup, include=FALSE}
# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "purrr",
  "metafor",
  "dygraphs"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")
source("./scripts/functions/MlTbl.R")
source("./scripts/functions/metaLmer.R")
source("./scripts/functions/meanViz.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings
knitr::knit_hooks$set(
  error = function(x, options) {
    paste('\n\n<div class="alert alert-danger">',
      gsub("##", "\n", gsub("^##\ Error", "**Error**", x)),
      "</div>",
      sep = "\n"
    )
  },
  warning = function(x, options) {
    paste('\n\n<div class="alert alert-warning">',
      gsub("##", "\n", gsub("^##\ Warning:", "**Warning**", x)),
      "</div>",
      sep = "\n"
    )
  },
  message = function(x, options) {
    paste('\n\n<div class="alert alert-info">',
      gsub("##", "\n", x),
      "</div>",
      sep = "\n"
    )
  }
)
htmltools::tagList(rmarkdown::html_dependency_font_awesome())

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

</br>

--------------------------------------------------------------------

</br> 

<i class="fas fa-exclamation-circle"></i> Note. Boxplots display the interquartile range (IQR, center box), and the whiskers extend 1.5*IQR from the lower and upper hinge. The white point indicates the mean and the white center line indicates the median.   

</br>

--------------------------------------------------------------------

</br> 


# **Data Preparation**  

In an initial preparatory step, we import the data into the R project environment and prepare the variables for further processing and later analyses.   

## Data Import  

The data were collected using two different survey tools. For the study with sojourners (Study 1: worker) we used the survey platform Qualtrics XM, whereas the studies with international students (Study 2: student), and the international medical professionals (Study 3: medical) were conducted using the survey framework FormR. This means that the datasets had inconsistent file formats and naming conventions. For the Qualtrics study we pre-processed some variables to ease the import process (for the syntax files see the SPS files in '_data/S1_Workers/processed/cleaned_' and for the raw data files see '_data/S1_Workers/raw_'). For the two other studies, we import the raw csv files from their respective folders.  

```{r formrImport}
# workers
# initial data cleaning was done in SPSS (syntax files are available in "")
dtWorker <- list(
  raw.pre = read_spss("data/S1_Workers/processed/cleaned/MT - Pre-Measure - 06-15-2018.sav"),
  raw.post = read_spss("data/S1_Workers/processed/cleaned/MT - Post-Measure - 06-15-2018.sav"),
  raw.morning = read_spss("data/S1_Workers/processed/cleaned/MT - Morning - 06-15-2018.sav"),
  raw.afternoon = read_spss("data/S1_Workers/processed/cleaned/MT - Afternoon - 06-15-2018.sav")
)

# students
dtStudents <- list(
  raw.pre = read.csv(file = "data/S2_Students/raw/AOTS_Pre.csv", header = T, sep = ","),
  raw.post = read.csv(file = "data/S2_Students/raw/AOTS_Post.csv", header = T, sep = ","),
  raw.daily = read.csv(file = "data/S2_Students/raw/AOTS_Daily.csv", header = T, sep = ",")
)

# young medical professionals
dtMedical <- list(
  raw.eligibility = read.csv("data/S3_Medical/raw/AOTM_Eligibility.csv"),
  raw.pre = read.csv("data/S3_Medical/raw/AOTM_Pre.csv"),
  raw.post = read.csv("data/S3_Medical/raw/AOTM_Post.csv"),
  raw.daily = read.csv("data/S3_Medical/raw/AOTM_Daily.csv")
)
```

## Data Cleaning & Data Exclusions  

### Worker

For the sojourner sample data was collected in four separate surveys: (1) the pre-measurement, (2) the daily morning survey, (3) the daily afternoon survey, as well as (4) a post-measurement. We combine the four individual surveys into one cohesive dataframe and drop superfluous variables that are not relevant to the analyses relevant here. We then format the time and date variables and add person- and measurement indices (for easy and meaningful addressing of the data). We also exclude our own test data.  
<i class="fas fa-info-circle"></i> _Note:_ All data preparation steps are saved in the '_dtWorker_' list. 

```{r cleanWorker}
#  important names for Morning and Afternoon
names.m <- c(
  "StartDate",
  "EndDate",
  "Finished",
  "Duration__in_seconds_",
  "RecordedDate",
  "ExternalReference",
  "Meta_Operating_System",
  "Contact_dum",
  "number",
  "time",
  "duration_1",
  "dyad.group",
  "gr_size",
  "gr_type_1",
  "gr_type_2",
  "gr_type_3",
  "gr_type_4",
  "gr_type_5",
  "gr_type_6",
  "gr_type_7",
  "gr_type_8",
  "gr_type_9",
  "gr_type_10",
  "gr_type_11",
  "gr_type_12",
  "gr_type_13",
  "gr_type_14",
  "gr_type_15",
  "gr_type_16",
  "gr_type_17_TEXT",
  "gr_context_1",
  "gr_context_2",
  "gr_context_3",
  "gr_context_4",
  "gr_context_5",
  "gr_context_6",
  "gr_context_7",
  "gr_context_8",
  "gr_context_9",
  "gr_context_10",
  "gr_context_11",
  "gr_context_12",
  "gr_context_13_TEXT",
  "gr_context_14_TEXT",
  "gr_dutchness",
  "dyad_type_1",
  "dyad_type_2",
  "dyad_type_3",
  "dyad_type_4",
  "dyad_type_5",
  "dyad_type_6",
  "dyad_type_7",
  "dyad_type_8",
  "dyad_type_9",
  "dyad_type_10",
  "dyad_type_11",
  "dyad_type_12",
  "dyad_type_13",
  "dyad_type_14",
  "dyad_type_15",
  "dyad_type_16",
  "dyad_type_17_TEXT",
  "Context_1",
  "Context_2",
  "Context_3",
  "Context_4",
  "Context_5",
  "Context_6",
  "Context_7",
  "Context_8",
  "Context_9",
  "Context_10",
  "Context_11",
  "Context_12",
  "Context_13_TEXT",
  "Context_14_TEXT",
  "keyMotive",
  "keymotive_fulfillemt_1",
  "keyMotive_Dutch_1",
  "autonomy_1",
  "competence_1",
  "relatedness_self_1",
  "relatedness_other_1",
  "qualityAccidental_1",
  "qualityVoluntary_1",
  "qualityCooperative_1",
  "qualityDutchy_1",
  "quality_overall_1",
  "quality_meaning_1",
  "quality_star_1",
  "wantInt",
  "desire_type_1",
  "desire_type_2",
  "desire_type_3",
  "desire_type_4",
  "desire_type_5",
  "desire_type_6",
  "desire_type_7",
  "desire_type_8",
  "desire_type_9",
  "desire_type_10",
  "desire_type_11",
  "desire_type_12",
  "desire_type_13",
  "desire_type_14",
  "desire_type_15",
  "desire_type_16",
  "desire_type_17_TEXT",
  "desire_context_1",
  "desire_context_2",
  "desire_context_3",
  "desire_context_4",
  "desire_context_5",
  "desire_context_6",
  "desire_context_7",
  "desire_context_8",
  "desire_context_9",
  "desire_context_10",
  "desire_context_11",
  "desire_context_12",
  "desire_context_13_TEXT",
  "desire_context_14_TEXT",
  "Reason_nodesire",
  "keyMotive_noInt",
  "keyMotive_noInt_fulf_1",
  "autonomy_NoInt_1",
  "competence_NoInt_1",
  "relatedness_1_NoInt_1",
  "thermometerDutch_1",
  "thermometerDutchInt_2",
  "ExWB_1",
  "MDMQ.v1_1",
  "MDMQ.v1_2",
  "MDMQ.v1_3",
  #"MDMQ.v1_3r",
  "MDMQ.v1_4",
  #"MDMQ.v1_4r",
  "MDMQ.v1_5",
  #"MDMQ.v1_5r",
  "MDMQ.v1_6",
  "MDMQ.v1_7",
  #"MDMQ.v1_7r",
  "MDMQ.v1_8",
  "MDMQ.v1_9",
  #"MDMQ.v1_9r",
  "MDMQ.v1_10",
  "MDMQ.v1_11",
  #"MDMQ.v1_11r",
  "MDMQ.v1_12",
  "MDMQ.v1_13",
  "MDMQ.v2_1",
  #"MDMQ.v2_1r",
  "MDMQ.v2_2",
  "MDMQ.v2_3",
  "MDMQ.v2_4",
  #"MDMQ.v2_4r",
  "MDMQ.v2_5",
  "MDMQ.v2_6",
  #"MDMQ.v2_6r",
  "MDMQ.v2_7",
  #"MDMQ.v2_7r",
  "MDMQ.v2_8",
  "MDMQ.v2_9",
  "MDMQ.v2_10",
  #"MDMQ.v2_10r",
  "MDMQ.v2_11",
  #"MDMQ.v2_11r",
  "MDMQ.v2_12",
  "MDMQ.v2_13",
  "alertness1",
  "calmness1",
  "valence1",
  "alertness2",
  "calmness2",
  "valence2",
  "inNonDutch",
  "NonDutchNum",
  "NonDutchType_1",
  "NonDutchType_2",
  "NonDutchType_3",
  "NonDutchType_4",
  "NonDutchType_5",
  "NonDutchType_6",
  "NonDutchType_7",
  "NonDutchType_8",
  "NonDutchType_9",
  "NonDutchType_10",
  "NonDutchType_11",
  "NonDutchType_12",
  "NonDutchType_13",
  "NonDutchType_14",
  "NonDutchType_15_TEXT",
  "date",
  "time.0",
  "LocationLatitude",
  "LocationLongitude"
)

names.a <- c(names.m, "keyInteraction_1", "keyInteractionTime")

# Create reduced data sets for morning and afternoon
dat.mo <- dtWorker$raw.morning[, names.m]
dat.mo$daytime <- "morning"

dat.af <- dtWorker$raw.afternoon[, names.a]
dat.af$daytime <- "afternoon"

# merge morning and afternoon measurements with indicator [+ clean up]
daily.dat <- rbind.fill(dat.mo, dat.af)
daily.dat <- daily.dat[daily.dat$ExternalReference != 55951, ]
dtWorker$daily <- daily.dat
rm(dat.mo, dat.af, names.m, names.a, daily.dat)

# names for pre-measurement
names.pre <- c(
  "Finished",
  "age",
  "Gender",
  "Living",
  "roommate_1",
  "roommate_2",
  "roommate_3",
  "nationality",
  "SecondNationality",
  "timeNL_1",
  "Reason_2",
  "Reason_5",
  "Reason_7",
  "Reason_8_TEXT",
  "DutchLang",
  "occupation_1",
  "occupation_2",
  "occupation_3",
  "occupation_4",
  "occupation_7",
  "CurrentEducation_1",
  "education_level",
  "EduLang_2",
  "RUG_faculty",
  "Study.0",
  "association",
  "DutchMeetNum",
  "DutchFriends_1",
  "assimilation",
  "separation",
  "integration",
  "marginalization",
  "VIA_heritage",
  "VIA_Dutch",
  "SSAS_surrounding",
  "SSAS_privat",
  "SSAS_public",
  "autonomy",
  "relatedness",
  "competence",
  "anxiety",
  "swl",
  "alertness",
  "calmness",
  "valence",
  "date",
  "time",
  "City",
  "ZIP",
  "id"
)

# reduced data set for pre measurement
dat.pre.red <- dtWorker$raw.pre[, names.pre]

# merge with daily data [+ clean up]
df.pre <- merge(
  x = dtWorker$daily,
  y = dat.pre.red,
  by.x = "ExternalReference",
  by.y = "id",
  all = T
)
rm(names.pre)

# adjust duplicate names to fit to indicate daily or pre measurement
names(df.pre) <- gsub("[[:punct:]]x", ".daily", names(df.pre))
names(df.pre) <- gsub("[[:punct:]]y", ".pre", names(df.pre))

# names for post measurement
names.post <- c(
  "ExternalReference",
  "assimilation",
  "separation",
  "integration",
  "marginalization",
  "VIA_heritage",
  "VIA_Dutch",
  "anxiety",
  "swl",
  "rosenberg",
  "social_support",
  "stress",
  "discrimination",
  "discrimination_month",
  "NLE_1month",
  "NLE_6month",
  "NLE_12month"
)

# reduced data set for post-measurement
dat.post.red <- dtWorker$raw.post[, names.post]

# merge post measurement with pre- and daily data
df <- merge(
  x = df.pre,
  y = dat.post.red,
  by.x = "ExternalReference",
  by.y = "ExternalReference",
  all = T
)

# adjust duplicate names to indicate pre or post
names(df) <- gsub("[[:punct:]]x", ".pre", names(df))
names(df) <- gsub("[[:punct:]]y", ".post", names(df))

# add to list
dtWorker$combined <- df

# create data frame with cleaned data
df <- dtWorker$combined %>%
  filter(
    Finished.pre == 1,
    Finished.daily == 1,
    !is.na(ExternalReference)
  )

# add running number as measurement ID within participants
df$measureID <- rowidv(df, cols = c("ExternalReference"))

df <- df %>%
  mutate(
    PID = as.numeric(factor(ExternalReference)),
    # participant ID
    TID = measureID - 1,
    # time ID with t0 = 0 for meaningfull intercept interpretations
    date = substr(StartDate, 1, 10),
    # awkward way of extracting date (best converted to )
    time = substr(StartDate, 12, 19),
    # awkward way of extracting time
    daynum = as.numeric(factor(date)),
    # all days as numeric for ordering
    daycor = ifelse(
      daytime == "morning" &
        period_to_seconds(hms(time)) < period_to_seconds(hms("12:00:00")) |
        daytime == "afternoon" &
          period_to_seconds(hms(time)) < period_to_seconds(hms("19:00:00")),
      daynum - 1,
      daynum
    ),
    # correctly identify which date the questionnaire is about
    daycor.lead = sprintf("%02d", daycor),
    daytime.lt = ifelse(daytime == "morning", "a", "b"),
    # morning / afternoon to a / b
    day_time = paste(daycor.lead, daytime.lt, sep = "_"),
    # combine day id with morning / afternoon
    session = as.numeric(factor(day_time)),
    # day and time identifier as numeric id
    SubTime = chron::times(time.0),
    time.daily = as.character(time.daily),
    PPDate = as.Date(df$date.daily),
    number = replace_na(number, 0),
    NonDutchNum = replace_na(NonDutchNum, 0)
  )

dtWorker$clean <- df

# clean up
rm(df.pre, names.post, dat.post.red, dat.pre.red, df)

# Export reduced Data
# write.csv(dtWorker$clean, "data/processed/MT_clean-merged_07-05-2018.csv", row.names = F)
# save(dtWorker$clean, file = "data/processed/MT_clean-merged_07-05-2018.RData")
```

### Student

For the student sample data was, similarly, collected in three separate surveys: (1) the pre-measurement, (2) the daily survey sent out at lunch and dinner time, and (3) a post-measurement. We combine the three individual surveys into one large dataframe and drop superfluous variables that are not relevant to the analyses relevant here. We exclude our own test data as well as one participant who entered the study twice (but gave different responses during the pre-measurement). We also reformat missing values and format core ID variables.  
<i class="fas fa-info-circle"></i> _Note:_ All data preparation steps are saved in the '_dtStudents_' list. 

```{r cleanStudents}
# our own test IDs
ownIDs <- c(
  "beautifulLionfishXXXR5rcgVBzGu8hPvOqrK8UBJBw4owvi9nfRFSFu3lMzYhE",
  "niceDogoXXXmB8JI5SFu78SF3DVof84mGUPPNUr14p2HYFTtp31a6D1OwAzM6F-K",
  "amusedQuailXXXmhuc_fpTp8vPkMwDH1BzjaH1d1kHSO1bsPEfsnaEYk4WeVBfPi",
  "juwGAbtXX0_1kmZtSVqKh3PGaHOICqUyU4iBkrT3nDsI_uifuD1gzKcZerxaM5FL"
)

# Prepare dfs for Cleaning
df.pre <- dtStudents$raw.pre %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!is.na(ended)) %>% # remove all who did not finish
  filter(!e_mail %in% .$e_mail[duplicated(.$e_mail)]) %>% # remove all who did the pre questionnaire multiple times (b/c inconsistent ratings scales)
  filter(!session %in% ownIDs) %>% # remove our own test
  mutate(session = as.character(session)) # turn factor into character strings (probably just precaution)

df.post <- dtStudents$raw.post %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!is.na(session)) %>% # remove own test runs
  filter(!session %in% ownIDs) %>% # remove our own test
  filter(session %in% df.pre$session) %>% # remove anyone who wasn't in the pre
  filter(!is.na(ended)) %>% # remove all who never finished
  filter(!session %in% .$session[duplicated(.$session)]) %>% # remove all duplicate sessions
  mutate(session = as.character(session)) # turn factor into character strings (probably just precaution)

df.daily <- dtStudents$raw.daily %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!session %in% ownIDs) %>% # remove our own test
  filter(session %in% df.pre$session) %>% # remove anyone who wasn't in the pre
  filter(!is.na(ended)) %>% # remove all who never finished
  mutate(session = as.character(session)) # turn factor into character strings (probably just precaution)

# merge daily with pre
dfPreDaily <- merge(
  x = df.daily,
  y = df.pre,
  by = "session",
  suffixes = c(".daily", ".pre"),
  all = F
)

# merge daily with post
dfCombined <- merge(
  x = dfPreDaily,
  y = df.post,
  by = "session",
  suffixes = c(".pre", ".post"),
  all = F
)

# add to list
dtStudents$clean <- dfCombined

# clean up workspace
rm(df.pre, df.daily, df.post, dfPreDaily, dfCombined, ownIDs)
```


### Medical

For the medical professionals sample data was, again, collected in three separate surveys: (1) the pre-measurement, (2) the daily survey sent out at lunch and dinner time, and (3) a post-measurement. We combine the three individual surveys into one large dataframe. We exclude our own test data. We also reformat missing values and format core ID variables.  
<i class="fas fa-info-circle"></i> _Note:_ All data preparation steps are saved in the '_dtMedical_' list. 

```{r cleanMedical}
# our own test IDs
ownIDs <- c(
  "test_LeonieXXXSklxecPLW0-FBPM4796o3pUwUhAY5jb9KGw8jQsKxWmGpa1Jiy", 
  "test_MaxXXXtOp_5dTNefIq0yKXtXt2IN6eEKxeHoPY9mlyvdsqPpLp1B0NGg4UL",
  "test_JannisXXXBsNqk62fOpX6chbd2tMWPptUdjjnhAqnQ3uBqckZ7gLIEoPlfZ",
  "quaintLeopardCatXXXAJ9cfSj-_SZLwNwMDxv_xv_iyr1Bg5YFLTlYdrjW0UXZY",
  "blue-eyedIndianElephantXXXLf5zPMpQCDGS3umFzIj-YVky7ivTItvvozW49m"
)

# Prepare dfs for Cleaning
df.pre <- dtMedical$raw.pre %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!is.na(ended)) %>% # remove all who did not finish
  filter(!session %in% ownIDs) %>% # remove our own test
  mutate(session = as.character(session)) # turn factor into character strings (probably just precaution)

df.post <- dtMedical$raw.post %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>% 
  filter(!is.na(session)) %>% # remove own test runs
  filter(!session %in% ownIDs) %>% # remove our own test
  filter(session %in% df.pre$session) %>% # remove anyone who wasn't in the pre
  #filter(!is.na(ended)) %>% # remove all who never finished [disabled because only relevant if data is missing]
  filter(!session %in% .$session[duplicated(.$session)]) %>% # remove all duplicate sessions
  mutate(session = as.character(session)) # turn factor into character strings (probably just precaution)

df.daily <- dtMedical$raw.daily %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!session %in% ownIDs) %>% # remove our own test
  filter(session %in% df.pre$session) %>% # remove anyone who wasn't in the pre
  #filter(!is.na(ended)) %>% # remove all who never finished [disabled because only relevant if data is missing]
  mutate(session = as.character(session)) # turn factor into character strings (probably just precaution)

# merge daily with pre
dfPreDaily <- merge(
  x = df.daily,
  y = df.pre,
  by = "session",
  suffixes = c(".daily", ".pre"),
  all = F
)

# merge daily with post
dfCombined <- merge(
  x = dfPreDaily,
  y = df.post,
  by = "session",
  suffixes = c(".pre", ".post"),
  all = F
)

# add to list
dtMedical$clean <- dfCombined

# clean up workspace
rm(df.pre, df.daily, df.post, dfPreDaily, dfCombined, ownIDs)
```


## Calculate needed transformations  

### Worker

For the worker sample, the data transformation stage had three main aims: 

1. We first corrected time indicators within the surveys. In some cases participants completed their daily diary surveys for the afternoon after midnight. In these cases the measurement still is in reference to the previous day and is indicated in the corrected variable.   
2. We then created indices of scales. Some indices were multi-item scales while some indices combine equivalent measurement for different situational circumstances (e.g., competence perceptions after interactions and at measurement occasions without interactions).   
3. Finally, we calculated several basic participant summaries (averages across all measurement occasions).   

```{r newVarsWorkers}
df <- dtWorker$clean

# Time and Date Variables
# remove seconds from afternoon time
df$SubTime[df$daytime == "afternoon"] <- paste0(substring(as.character(df$time.0[df$daytime == "afternoon"]), 4, 8), ":00")
df$time.daily[df$daytime == "afternoon" &
  !is.na(df$time.daily != "<NA>")] <- paste0(substring(as.character(df$time.daily[df$daytime == "afternoon" &
  !is.na(df$time.daily != "<NA>")]), 4, 8), ":00")

# Correct morning / afternoon date where survey was collected the day after to indicate the correct date that was targeted
df$PPDate[df$SubTime < "11:50:00" &
  df$daytime == "morning"] <- df$PPDate[df$SubTime < "11:50:00" &
  df$daytime == "morning"] - 1
df$PPDate[df$SubTime < "18:50:00" &
  df$daytime == "afternoon"] <- df$PPDate[df$SubTime < "18:50:00" &
  df$daytime == "afternoon"] - 1

# Make time IDs consistent with later studies
df$TID <- paste(df$PPDate, str_to_title(df$daytime))
df$TIDnum <- as.numeric(factor(df$TID %>% gsub(" Morning", "-A", .) %>% gsub(" Afternoon", "-B", .)))

# Make contact dummies consistent with later studies
df$IntergroupContact <- df$Contact_dum

df <- df %>%
  rowwise() %>%
  mutate(
    InteractionDum = sum(Contact_dum, inNonDutch, na.rm = FALSE),
    InteractionDum = if_else(InteractionDum > 0, 1, InteractionDum),
    alertness = sum(alertness1, alertness2, na.rm = TRUE),
    calmness = sum(calmness1, calmness2, na.rm = TRUE),
    valence = sum(valence1, valence2, na.rm = TRUE)
  ) %>%
  ungroup()

# Need scales
df$InteractionNeedFullfillment <- df$keymotive_fulfillemt_1
df$DaytimeNeedFullfillment <- df$keyMotive_noInt_fulf_1

df$keyMotiveFulfilled <- rowSums(df[, c("keymotive_fulfillemt_1", "keyMotive_noInt_fulf_1")], na.rm = T)
df$autonomy.daily.all <- rowSums(df[, c("autonomy_1", "autonomy_NoInt_1")], na.rm = T)
df$competence.daily.all <- rowSums(df[, c("competence_1", "competence_NoInt_1")], na.rm = T)
# cor(df$relatedness_other_1, df$relatedness_self_1,use="complete.obs")
df$relatedness.daily.all <- rowMeans(df[, c(
  "relatedness_other_1",
  "relatedness_self_1",
  "relatedness_1_NoInt_1"
)], na.rm = T)

pairs.panels.new(
  df[c("relatedness_self_1", "relatedness_other_1")],
  labels = c(
    "I shared information about myself.",
    "X shared information about themselves."
  )
)
df$relatedness_1 <- rowMeans(df[, c("relatedness_other_1", "relatedness_self_1")], na.rm = T)

df$Autonomy <- df$autonomy.daily.all
df$Competence <- df$competence.daily.all
df$Relatedness <- df$relatedness.daily.all

# Make Outgroup Attitudes consistent with later studies
df$AttitudesDutch <- df$thermometerDutch_1
df$AttitudesPartner <- df$thermometerDutchInt_2

# Make experienced well-being consistent with later studies
df$ExWB <- df$ExWB_1

# summarize by participant (check that everything is within pp might not be the case for )
between <- df %>%
  group_by(ExternalReference) %>%
  mutate(
    CtContactNL = sum(Contact_dum),
    CtContactNonNl = sum(inNonDutch),
    CtContactNLAll = sum(number),
    CtContactNonNlAll = sum(NonDutchNum),
    AvKeyNeed = mean(keyMotiveFulfilled, na.rm = T),
    AvKeyNeedInt = mean(keymotive_fulfillemt_1, na.rm = T),
    AvKeyNeedNoInt = mean(keyMotive_noInt_fulf_1, na.rm = T),
    AvAutonomy = mean(autonomy.daily.all, na.rm = T),
    AvCompetence = mean(competence.daily.all, na.rm = T),
    AvRelatedness = mean(relatedness.daily.all, na.rm = T),
    AvThermo = mean(thermometerDutch_1, na.rm = T),
    AvWB = mean(ExWB_1, na.rm = T)
  ) %>%
  ungroup() %>%
  mutate(
    CtContactNL_c = scale(CtContactNL, scale = FALSE),
    AvKeyNeedInt_c = scale(AvKeyNeedInt, scale = FALSE),
    AvKeyNeed_c = scale(AvKeyNeed, scale = FALSE),
    CtContactNL_z = scale(CtContactNL, scale = TRUE),
    AvKeyNeedInt_z = scale(AvKeyNeedInt, scale = TRUE),
    AvKeyNeed_z = scale(AvKeyNeed, scale = TRUE)
  )

warning(
  "some variable transformations (esp. _c and _z) might be across all participants (i.e., not within PP). See next step."
)

dtWorker$full <- between
rm(df, between)

# dataframe where interaction types are recoded
workerInteractionType <- dtWorker$full %>%
  mutate(
    OutgroupInteraction = as_factor(Contact_dum),
    NonOutgroupInteraction = as_factor(inNonDutch)
  )

# Create variables centered and standardized within Participant
# i.e., divide into trait and state
workerWithinBetween <-
  MlTraitState(
    data = workerInteractionType,
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "competence.daily.all",
        "autonomy.daily.all",
        "relatedness.daily.all",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1", 
        "OutgroupInteraction",
        "NonOutgroupInteraction"
      )
  )

workerOutWithinBetween <-
  MlTraitState(
    data = workerInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "keyMotiveFulfilled",
        "thermometerDutch_1",
        "keymotive_fulfillemt_1",
        "competence_1",
        "autonomy_1",
        "relatedness_1", 
        "quality_overall_1"
      )
  )


# Between participants contact frequency
workerContactFreq <- dtWorker$full %>%
  group_by(PID) %>%
  summarise(
    n = n(),
    SumContactNL = sum(Contact_dum),
    PercContactNL = SumContactNL / n * 100,
    SumContactNLAll = sum(number),
    AvAttitude = mean(thermometerDutch_1, na.rm = T)
  ) %>%
  mutate(
    WinSumContactNL = DescTools::Winsorize(SumContactNL),
    WinSumContactNLAll = DescTools::Winsorize(SumContactNLAll)
  )

# save cleaned data
# save(df.btw, file = "data/processed/df.btw.RData")
# write_sav(df.btw, "data/processed/MT_clean-merged_pre-post.sav")

# export data to Mplus
# df.mplus = remove_all_labels(select(df,
#                                     PID, session,
#                                     thermometerDutch_1, inNonDutch, Contact_dum,
#                                     keyMotiveFulfilled, autonomy.daily.all, competence.daily.all, relatedness.daily.all))
# names(df.mplus)= c("PID", "session", "att", "intin", "intout", "keymot", "aut", "comp", "rel")
# mplus = df.mplus[order(df.mplus$PID, df.mplus$session),]
# mplus.intcont = mplus[mplus$intout==1,]
# prepareMplusData(mplus.intcont, "data/processed/dynamic-subset-intonly.dat")
```

### Student

For the student sample, the data transformation stage had five main aims: 

1. We first create person, survey type, and measurement ID variables.   
2. We then created indices of scales. Some indices were multi-item scales while some indices combine equivalent measurement for different situational circumstances (e.g., competence perceptions after interactions and at measurement occasions without interactions).   
3. We add information about the interaction partner to the beep during which a person was selected as an interaction partner.   
4. We cluster mean-center key variables within participants.   
5. Finally, we calculated several basic participant summaries (averages across all measurement occasions).   

```{r newVarsStudents}
df <- dtStudents$clean

# Add ID variables
df$PID <- as.numeric(factor(df$session)) # participant ID

# order time
df$TID <- factor(df$date_period, levels = unique(dtStudents$raw.daily$date_period))
df$TIDnum <- as.numeric(df$TID) # get numeric TID

# check whether time ordering worked
df <- df %>%
  arrange(PID, TID) # %>%
# View()

# Interaction as Factor
df$interaction.f <-
  factor(df$Interaction,
    levels = c("no interaction", "Dutch", "Non-Dutch")
  )
df$intNL <- ifelse(df$Interaction == "Dutch", 1, 0)
df$intNonNL <- ifelse(df$Interaction == "Non-Dutch", 1, 0)

df$IntergroupContact <- (df$IntergroupContact-2)*-1

# Fix naming issues
df$AttitudesPartner <- df$AttitdutuesPartnerstick

# -------------------------------------------------------------------------------------------------------------
#                                       Combine Variables
# -------------------------------------------------------------------------------------------------------------
# Relatedness
pairs.panels.new(
  df[c("RelatednessSelf", "RelatednessOther")],
  labels = c(
    "I shared information about myself.",
    "X shared information about themselves."
  )
)
df$RelatednessInteraction <- rowMeans(df[c("RelatednessSelf", "RelatednessOther")], na.rm = TRUE)
df$RelatednessInteraction[df$RelatednessInteraction == "NaN"] <- NA
# Relatedness Overall (JANNIS NOT SURE THESE ARE CORRECT, CHANGE ROWS?; J: Changed "NaN" in df$RelatednessInteraction to NA() should work now)
df$Relatedness <-
  rowMeans(df[, c("RelatednessInteraction", "RelatednessNoInteraction")],
           na.rm = TRUE) %>%
  ifelse(is.nan(.), NA, .)

# Core Need
df$DaytimeNeedFullfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFullfillment)] <-
  df$KeyNeedFullfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFullfillment)]

df$InteractionNeedFullfillment <- NA 
df$InteractionNeedFullfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFullfillment)] <- 
  df$KeyNeedFullfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFullfillment)]


# Pro-Sociality
df$ProSo <-
  rowMeans(df[, c("ProSo1", "ProSo2", "ProSo3", "ProSo4")], na.rm = T)
# Anti-Sociality
df$AntiSo <-
  rowMeans(df[, c("AntiSo1", "AntiSo2", "AntiSo3", "AntiSo4")], na.rm = T)


# -------------------------------------------------------------------------------------------------------------
#                                 Add Variables related to interaction partner
# -------------------------------------------------------------------------------------------------------------
# create function for later lapply
createIntPartDf <- function(inp) {
  # prepare the dataframe so that we can forloop over it later
  tmp <- data.frame(
    CC = as.character(inp$CC),
    NewCC = as.character(inp$NewCC),
    NewName = as.character(inp$NewName),
    NewCloseness = inp$NewCloseness,
    NewGender = inp$NewGender,
    NewEthnicity = as.character(inp$NewEthnicity),
    NewRelationship = as.character(inp$NewRelationship)
  )

  tmp$CC2 <- recode(tmp$CC, "SOMEONE ELSE" = "NA")
  tmp$CC2 <-
    ifelse(
      tmp$CC == 1 |
        tmp$CC == "SOMEONE ELSE",
      as.character(tmp$NewName),
      as.character(tmp$CC2)
    )
  # maybe add [[:space:]]\b to remove space before word boundary or ^[[:space:]] to remove space in the beginning of a string
  tmp$CC2 <- gsub("^[[:space:]]", "", tmp$CC2)
  tmp$NewName <- gsub("^[[:space:]]", "", tmp$NewName)

  # open the variables that will be filled up in the foor-loop
  tmp$closeness <- rep(NA, nrow(tmp))
  tmp$gender <- rep(NA, nrow(tmp))
  tmp$ethnicity <- rep(NA, nrow(tmp))
  tmp$relationship <- rep(NA, nrow(tmp))

  # Run the for-loop. It finds the variables related to the name of the interaction partner. If there is a repeating interaction
  # partner (i.e. CC2) it takes the value (i.e. NewCloseness) from the first interaction (i.e. NewName)
  for (i in 1:nrow(tmp)) {
    if (is.na(tmp$CC2[i])) {
      next
    } else {
      tmp$closeness[i] <-
        na.omit(tmp$NewCloseness[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # find closeness where CC2 matches NewName (na.omit + [1] to get the number)
      tmp$gender[i] <-
        na.omit(tmp$NewGender[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # (na.omit + [1] to get the number and not the rest of the na.omit list)
      tmp$ethnicity[i] <-
        na.omit(as.character(tmp$NewEthnicity[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1] # PROBLEM IS THAT THERE ARE TOO MANY NA's: Difficult to deal with
      tmp$relationship[i] <-
        na.omit(as.character(tmp$NewRelationship[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1]
    }
  }

  out <- tmp
  out
}

# split df per participants and run function
PP <- split(df, df$PID)
PP <- lapply(PP, createIntPartDf)
rm(createIntPartDf)

# add variables back to df
remergePP <- do.call(rbind.data.frame, PP)
colnames(remergePP) <-
  paste(colnames(remergePP), "_Calc", sep = "")
df <- cbind(df, remergePP)
rm(remergePP, PP)

# -------------------------------------------------------------------------------------------------------------
#                                 Center Relevant Variables
# -------------------------------------------------------------------------------------------------------------

df <- df %>%
  group_by(PID) %>%
  mutate(
    KeyNeedFullfillment.cm = mean(KeyNeedFullfillment, na.rm = TRUE),
    # cluster mean (mean of PP)
    KeyNeedFullfillment.cwc = KeyNeedFullfillment - KeyNeedFullfillment.cm,
    # cluster mean centered (within PP centered)
    closeness.cm = mean(closeness_Calc, na.rm = TRUE),
    closeness.cwc = closeness_Calc - closeness.cm
  ) %>%
  ungroup()

# store
dtStudents$full <- df
rm(df)

# Between participants contact frequency
studentContactFreq <- dtStudents$full %>%
  group_by(PID) %>%
  summarise(
    n = n(),
    SumContactNL = sum(InteractionDumDutch),
    PercContactNL = SumContactNL / n * 100,
    SumContactNLAll = sum(ContactNum[InteractionDumDutch == 1], na.rm = TRUE),
    AvAttitude = mean(AttitudesDutch, na.rm = TRUE),
    AvQuality = mean(quality_overall, na.rm = TRUE)
  ) %>%
  mutate(
    WinSumContactNL = DescTools::Winsorize(SumContactNL),
    WinSumContactNLAll = DescTools::Winsorize(SumContactNLAll)
  )

# dataframe where interaction types are recoded
studentInteractionType <- dtStudents$full %>%
  mutate(
    NonDutchContact = tidyr::replace_na(NonDutchContact, 2), # make second non-Dutch countable
    NonDutchContact = NonDutchContact*-1+2 # recode (yes = 1 -> 1, no = 2 -> 0)
  ) %>%
  mutate(
    OutgroupInteraction = factor(
      InteractionDumDutch,
      levels = c(0, 1),
      labels = c("No", "Yes")
    ),
    NonOutgroupInteraction = factor(
      rowSums(select(., c(InteractionDumNonDutch, NonDutchContact))), # combine the two non-Dutch Q.,
      levels = c(0, 1),
      labels = c("No", "Yes")
    )
  )

# select a subset of IDs to display in plots
studentPltIDs <-
  studentInteractionType %>%
  group_by(PID) %>%
  summarise(n = n()) %>%
  slice_max(n, n = 20) %>% # chose the 20 with the most number of measurements
  select(PID) %>%
  as.matrix %>%
  as.vector

# select a subset of IDs to display in plots (only outgroup interactions)
studentOutPltIDs <-
  studentInteractionType %>%
  filter(OutgroupInteraction == "Yes") %>%
  group_by(PID) %>%
  summarise(n = n()) %>%
  slice_max(n, n = 20) %>% # chose the 20 with the most number of measurements
  select(PID) %>%
  as.matrix %>%
  as.vector

# Center within and between
# divide into trait and state
studentWithinBetween <-
  MlTraitState(
    data = studentInteractionType,
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall",
        "OutgroupInteraction",
        "NonOutgroupInteraction"
      )
  )
studentOutWithinBetween <-
  MlTraitState(
    data = studentInteractionType %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "KeyNeedFullfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AttitudesDutch",
        "quality_overall"
      )
  )

```

### Medical

For the medical professional sample, the data transformation stage had five main aims: 

1. We first create person, survey type, and measurement ID variables.   
2. We then created indices of scales. Some indices were multi-item scales while some indices combine equivalent measurement for different situational circumstances (e.g., competence perceptions after interactions and at measurement occasions without interactions).   
3. We cluster mean-center key variables within participants.   
4. Finally, we calculated several basic participant summaries (averages across all measurement occasions).   

```{r newVarsMedical}
df <- dtMedical$clean

# Add ID variables
df$PID <- as.numeric(factor(df$session)) # participant ID

# order time
df$TID <-
  factor(df$date_period, levels = unique(dtMedical$raw.daily$date_period))
df$TIDnum <- as.numeric(df$TID) # get numeric TID

# check whether time ordering worked
df <- df %>%
  arrange(PID, TID) # %>%
# View()

# Interaction as Factor
df$interaction.f <-
  factor(df$Interaction,
    levels = c("no interaction", "Dutch", "Non-Dutch")
  )
df$intNL <- ifelse(df$Interaction == "Dutch", 1, 0)
df$intNonNL <- ifelse(df$Interaction == "Non-Dutch", 1, 0)

df <- df %>%
  mutate(
    NonDutchContact = replace_na(NonDutchNum, 0), # make second non-Dutch countable
    NonDutchContact = ifelse(NonDutchContact > 1, 1, 0) # recode (yes = 1 -> 1, no = 2 -> 0)
  ) %>%
  mutate(
    OutgroupInteraction = factor(
      InteractionDumDutch,
      levels = c(0, 1),
      labels = c("No", "Yes")
    ),
    NonOutgroupInteraction = factor(
      rowSums(select(., c(InteractionDumNonDutch, NonDutchContact)), na.rm = TRUE), # combine the two non-Dutch Q.,
      levels = c(0, 1),
      labels = c("No", "Yes")
    )
  )

df$IntergroupContact <- (df$IntergroupContact-2)*-1


# -------------------------------------------------------------------------------------------------------------
#                                       Combine Variables
# -------------------------------------------------------------------------------------------------------------
# Relatedness
pairs.panels.new(
  df[c("RelatednessSelf", "RelatednessOther")],
  labels = c(
    "I shared information about myself.",
    "X shared information about themselves."
  )
)
df$RelatednessInteraction <-
  rowMeans(df[c("RelatednessSelf", "RelatednessOther")], na.rm = TRUE)
df$RelatednessInteraction[df$RelatednessInteraction == "NaN"] <- NA
# Relatedness Overall (JANNIS NOT SURE THESE ARE CORRECT, CHANGE ROWS?; J: Changed "NaN" in df$RelatednessInteraction to NA() should work now)
df$Relatedness <-
  rowMeans(df[, c("RelatednessInteraction", "RelatednessNoInteraction")],
           na.rm = TRUE) %>%
  ifelse(is.nan(.), NA, .)


df$DaytimeNeedFullfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFulfillment)] <-
  df$KeyNeedFulfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFulfillment)]

df$DaytimeNeedImportance <- NA 
df$DaytimeNeedImportance[df$InteractionDum == 1 & !is.na(df$DaytimeNeedFulfillment)] <- 
  df$DaytimeNeedFulfillment[df$InteractionDum == 1 & !is.na(df$DaytimeNeedFulfillment)]


df$InteractionNeedFullfillment <- NA 
df$InteractionNeedFullfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFulfillment)] <- 
  df$KeyNeedFulfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFulfillment)]

df$InteractionNeedImportance <- NA 
df$InteractionNeedImportance[df$InteractionDum == 1 & !is.na(df$KeyNeedImp)] <- 
  df$KeyNeedImp[df$InteractionDum == 1 & !is.na(df$KeyNeedImp)]


# Pro-Sociality
df$ProSo <-
  rowMeans(df[, c("ProSo1", "ProSo2", "ProSo3", "ProSo4")], na.rm = TRUE)
# Anti-Sociality
df$AntiSo <-
  rowMeans(df[, c("AntiSo1", "AntiSo2", "AntiSo3", "AntiSo4")], na.rm = TRUE)

# Allport's Conditions
df %>%
  #filter(OutgroupInteraction == "Yes") %>%
  select(
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  ) %>%
  pairs.panels.new

df %>%
  #filter(OutgroupInteraction == "Yes") %>%
  select(
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  ) %>%
  psych::describe(., skew=F,ranges=T) %>%
  as.data.frame() %>%
  select(-vars) %>%
  kable(., caption = "Descriptives of Allport's Condition items") %>% 
  kable_styling("hover", full_width = F, latex_options = "hold_position")



iaWorkerAllport <- 
  df %>%
  #filter(OutgroupInteraction == "Yes") %>%
  select(
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  )

sjPlot::tab_itemscale(iaWorkerAllport)

pca <- parameters::principal_components(iaWorkerAllport)
factor.groups <- parameters::closest_component(pca)

sjPlot::tab_itemscale(iaWorkerAllport, factor.groups)

ltm::cronbach.alpha(na.omit(iaWorkerAllport), CI = TRUE)

data <- 
  df %>%
  select(
    PID,
    TIDnum,
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  ) %>%
  drop_na %>%
  melt(
    ., 
    id.vars = c("PID", "TIDnum")
  )


horst::nestedAlpha(item.level.1 = "value",
                   level.2      = "TIDnum",
                   level.3      = "PID",
                   data         = data)
rm(data)

iaWorkerAllportScale <- 
  iaWorkerAllport %>%
  Scale::Scale() %>%
  Scale::ItemAnalysis()

df$AllportsCondition <-
  scoreItems(
    keys = c(1, 1, 1, 1),
    items = df %>% select(
      InteractionContextEqualStatus,
      KeyNeedShared,
      InteractionContextCooperative,
      InteractionContextvoluntary
    ),
    min = 0,
    max = 100
  )$scores

as.data.frame(psych::describe(df$AllportsCondition, skew=T)) %>%
  mutate(vars = "Allport's Conditions Index") %>%
  kable(., caption = "Allport's Conditions: Scale Descriptives", row.names = FALSE) %>% 
  kable_styling("hover", full_width = F, latex_options = "hold_position")

ggplot(df, aes(x = AllportsCondition)) +
  geom_histogram() +
  theme_Publication()

# -------------------------------------------------------------------------------------------------------------
#                                 Add Variables related to interaction partner
# -------------------------------------------------------------------------------------------------------------
# create function for later lapply
createIntPartDf <- function(inp) {
  # prepare the dataframe so that we can forloop over it later
  tmp <- data.frame(
    CC = as.character(inp$CC),
    NewCC = as.character(inp$NewCC),
    NewName = as.character(inp$NewName),
    NewCloseness = inp$NewCloseness,
    NewGender = inp$NewGender,
    NewEthnicity = as.character(inp$NewEthnicity),
    NewRelationship = as.character(inp$NewRelationship)
  )

  tmp$CC2 <- recode(tmp$CC, "SOMEONE ELSE" = "NA")
  tmp$CC2 <-
    ifelse(
      tmp$CC == 1 |
        tmp$CC == "SOMEONE ELSE",
      as.character(tmp$NewName),
      as.character(tmp$CC2)
    )
  # maybe add [[:space:]]\b to remove space before word boundary or ^[[:space:]] to remove space in the beginning of a string
  tmp$CC2 <- gsub("^[[:space:]]", "", tmp$CC2)
  tmp$NewName <- gsub("^[[:space:]]", "", tmp$NewName)

  # open the variables that will be filled up in the foor-loop
  tmp$closeness <- rep(NA, nrow(tmp))
  tmp$gender <- rep(NA, nrow(tmp))
  tmp$ethnicity <- rep(NA, nrow(tmp))
  tmp$relationship <- rep(NA, nrow(tmp))

  # Run the for-loop. It finds the variables related to the name of the interaction partner. If there is a repeating interaction
  # partner (i.e. CC2) it takes the value (i.e. NewCloseness) from the first interaction (i.e. NewName)
  for (i in 1:nrow(tmp)) {
    if (is.na(tmp$CC2[i])) {
      next
    } else {
      tmp$closeness[i] <-
        na.omit(tmp$NewCloseness[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # find closeness where CC2 matches NewName (na.omit + [1] to get the number)
      tmp$gender[i] <-
        na.omit(tmp$NewGender[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # (na.omit + [1] to get the number and not the rest of the na.omit list)
      tmp$ethnicity[i] <-
        na.omit(as.character(tmp$NewEthnicity[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1] # PROBLEM IS THAT THERE ARE TOO MANY NA's: Difficult to deal with
      tmp$relationship[i] <-
        na.omit(as.character(tmp$NewRelationship[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1]
    }
  }

  out <- tmp
  out
}

# split df per participants and run function
PP <- split(df, df$PID)
PP <- lapply(PP, createIntPartDf)
rm(createIntPartDf)

# add variables back to df
remergePP <- do.call(rbind.data.frame, PP)
colnames(remergePP) <-
  paste(colnames(remergePP), "_Calc", sep = "")
df <- cbind(df, remergePP)
rm(remergePP, PP)

# -------------------------------------------------------------------------------------------------------------
#                                 Center Relevant Variables
# -------------------------------------------------------------------------------------------------------------
# divide into trait and state
medicalOutWithinBetween <-
  MlTraitState(
    data = df %>% filter(OutgroupInteraction == "Yes"),
    id = "PID",
    selection =
      c(
        "KeyNeedFulfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AllportsCondition",
        "AttitudesDutch",
        "qualityOverall"
      )
  )

medicalWithinBetween <-
  MlTraitState(
    data = df,
    id = "PID",
    selection =
      c(
        "KeyNeedFulfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AllportsCondition",
        "AttitudesDutch",
        "qualityOverall",
        "OutgroupInteraction",
        "NonOutgroupInteraction"
      )
  )

df <- # keep only for compatibility of old framgents
  MlTraitState(
    data = df,
    id = "PID",
    selection =
      c(
        "KeyNeedFulfillment",
        "Competence",
        "Autonomy",
        "Relatedness",
        "AllportsCondition",
        "AttitudesDutch",
        "qualityOverall"
      )
  )

# store
dtMedical$full <- df
rm(df)


# Between participants contact frequency
medicalContactFreq <- 
  dtMedical$full %>%
  group_by(PID) %>%
  summarise(
    n = n(),
    SumContactNL = sum(InteractionDumDutch, na.rm = TRUE),
    PercContactNL = SumContactNL / n * 100,
    SumContactNLAll = sum(ContactNum[InteractionDumDutch == 1], na.rm = TRUE),
    AvAttitude = mean(AttitudesDutch, na.rm = TRUE),
    AvQuality = mean(qualityOverall, na.rm = TRUE)
  ) %>%
  mutate(
    WinSumContactNL = DescTools::Winsorize(SumContactNL),
    WinSumContactNLAll = DescTools::Winsorize(SumContactNLAll)
  )

# select a subset of IDs to display in plots
medicalPltIDs <-
  dtMedical$full %>%
  group_by(PID) %>%
  summarise(n = n()) %>%
  slice_max(n, n = 20) %>% # chose the 20 with the most number of measurements
  select(PID) %>%
  as.matrix %>%
  as.vector

# select a subset of IDs to display in plots (only outgroup interactions)
medicalOutPltIDs <-
  dtMedical$full %>%
  filter(OutgroupInteraction == "Yes") %>%
  group_by(PID) %>%
  summarise(n = n()) %>%
  slice_max(n, n = 20) %>% # chose the 20 with the most number of measurements
  select(PID) %>%
  as.matrix %>%
  as.vector
```


## Data Availability and Time Scales

As one of our main analyses is a three-mode principal component analysis (3MPCA) we begin by assessing the amount of missing data in each of the ESM studies. To assess the missingness in detail, we prepare a data availability table of whether data is available or missing for each possible measurement point (data + morning/afternoon) for all individual participants. We then export the data availability tables as comma separated value files (.csv) to be assessed in detail using a spreadsheet program (such as MS Excel).   

```{r workerDataAvailability}
dtworkerMissing <- dtWorker$full %>%
  select(
    PID,
    Finished.daily,
    PPDate,
    daytime,
    TID
  ) %>%
  mutate(
    date_period = paste(PPDate, daytime, sep = " "),
    available = 1
  )

library(reshape)
dtworkerAvailability <- reshape::cast(dtworkerMissing, PID ~ TID)
write.csv(dtworkerAvailability, "data/S1_Workers/processed/workerAvailability.csv")
```

```{r studentDataAvailability}
dtstudentMissing <- dtStudents$full %>%
  select(
    PID,
    date.daily,
    periodMA,
    date_period,
    TID
  ) %>%
  mutate(
    TID = as.numeric(TID),
    available = 1
  )

dtstudentAvailability <- reshape::cast(dtstudentMissing, PID ~ TID)
write.csv(dtstudentAvailability, "data/S2_Students/processed/studentAvailability.csv")
```

```{r medicalDataAvailability}
dtMedicalMissing <- dtMedical$full %>%
  select(
    PID,
    date.daily,
    periodMA,
    date_period,
    TID
  ) %>%
  mutate(
    TID = as.numeric(TID),
    available = 1
  )

dtMedicalAvailability <- reshape::cast(dtMedicalMissing, PID ~ TID)
write.csv(dtMedicalAvailability, "data/S3_Medical/processed/medicalAvailability.csv")
```

</br>

--------------------------------------------------------------------

</br> 

# **Plots per Item**

The three-mode PCA ultimately aims to explain the most variance with the fewest components (by maximizing the variance of data mapped in a lower dimensional space --- often by maximally separating groups of cases with similar variable patterns). Importantly, this procedure depends on variances and covariances to be present within the data. As one of our three modes is time and variance over time is not always given (e.g., because a variable is stable over the measured time span, such as personality over a month), it becomes important to assess whether a dimension reduction is possible for the variables measured during the measured time period. We, thus, start by visually inspecting the average changes and variance developments of all potentially relevant variables. We hope so see changes within the means and standard deviations over the measurement period. 

## Study 1 (Worker)

The first study, utilized not only the smallest sample but also a slightly different set of measured variables compared to the later two studies. Several variables are consistent across all three studies (e.g., types of social interactions, interaction needs, self-determiantion theory needs, outgroup attitudes, and experienced well-being). Study 1 additionally included several emotion and mood measurements but fewer cognitive and behavioral measures than studies two and three.  

We first select all potentially relevant variables and their labels, and then group the variables in small groups of one to three variables for plotting. 

```{r workerDataSelection}
varListWorker <- 
  c(
    "IntergroupContact",
    "InteractionDum",
    "DaytimeNeedFullfillment",
    "InteractionNeedFullfillment",
    "Autonomy",
    "Competence",
    "Relatedness",
    "AttitudesDutch",
    "AttitudesPartner",
    "ExWB",
    "alertness",
    "calmness",
    "valence",
    "MDMQ.v1_1",
    "MDMQ.v1_2",
    "MDMQ.v1_3",
    "MDMQ.v1_4",
    "MDMQ.v1_5",
    "MDMQ.v1_6",
    "MDMQ.v1_7",
    "MDMQ.v1_8",
    "MDMQ.v1_9",
    "MDMQ.v1_10",
    "MDMQ.v1_11",
    "MDMQ.v1_12",
    "MDMQ.v1_13",
    "MDMQ.v2_1",
    "MDMQ.v2_2",
    "MDMQ.v2_3",
    "MDMQ.v2_4",
    "MDMQ.v2_5",
    "MDMQ.v2_6",
    "MDMQ.v2_7",
    "MDMQ.v2_8",
    "MDMQ.v2_9",
    "MDMQ.v2_10",
    "MDMQ.v2_11",
    "MDMQ.v2_12",
    "MDMQ.v2_13"
  )

varNameListWorker <- 
  c(
    "IntergroupContact" = "Dutch Interaction",
    "InteractionDum" = "Any Interaction",
    "DaytimeNeedFullfillment" = "Daytime Core Motive Fulfillment",
    "InteractionNeedFullfillment" = "Interaction Core Motive Fulfillment",
    "Autonomy" = "Autonomy",
    "Competence" = "Competence",
    "Relatedness" = "Relatedness",
    "AttitudesDutch" = "Outgroup Attitude",
    "AttitudesPartner" = "Attitude Interaction Partner",
    "ExWB" = "Sadness Happiness",
    "alertness" = "Alertness",
    "calmness" = "Calmness",
    "valence" = "Emotional Valence",
    "MDMQ.v1_1" = "content",
    "MDMQ.v1_2" = "rested",
    "MDMQ.v1_3" = "restless",
    "MDMQ.v1_4" = "bad",
    "MDMQ.v1_5" = "worn-out",
    "MDMQ.v1_6" = "composed",
    "MDMQ.v1_7" = "tired",
    "MDMQ.v1_8" = "great",
    "MDMQ.v1_9" = "uneasy",
    "MDMQ.v1_10" = "energetic",
    "MDMQ.v1_11" = "uncomfortable",
    "MDMQ.v1_12" = "relaxed",
    "MDMQ.v1_13" = "alive and vital",
    "MDMQ.v2_1" = "sleepy",
    "MDMQ.v2_2" = "good",
    "MDMQ.v2_3" = "at ease",
    "MDMQ.v2_4" = "unhappy",
    "MDMQ.v2_5" = "alert",
    "MDMQ.v2_6" = "discontent",
    "MDMQ.v2_7" = "tense",
    "MDMQ.v2_8" = "fresh",
    "MDMQ.v2_9" = "happy",
    "MDMQ.v2_10" = "nervous",
    "MDMQ.v2_11" = "exhausted",
    "MDMQ.v2_12" = "calm",
    "MDMQ.v2_13" = "alive and vital"
  )

dtWorker$viz <- list()

dtWorker$vizall <- dtWorker$full %>%
  select(
    PID,
    TID,
    TIDnum,
    all_of(varListWorker)
  )

dtWorker$viz$Interaction <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    IntergroupContact,
    InteractionDum
  )

dtWorker$viz$KeyNeed <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    DaytimeNeedFullfillment,
    InteractionNeedFullfillment
  )

dtWorker$viz$SDT <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    Autonomy,
    Relatedness, 
    Competence
  )

dtWorker$viz$Attitudes <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    starts_with("Attitudes")
  )

dtWorker$viz$WB <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    ExWB
  )

dtWorker$viz$MoodOverall <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    alertness,
    calmness,
    valence
  )

dtWorker$viz$MoodV01Pt01 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v1_1,
    MDMQ.v1_2
  )

dtWorker$viz$MoodV01Pt02 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v1_3,
    MDMQ.v1_4
  )

dtWorker$viz$MoodV01Pt03 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v1_5,
    MDMQ.v1_6
  )

dtWorker$viz$MoodV01Pt04 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v1_7,
    MDMQ.v1_8
  )

dtWorker$viz$MoodV01Pt05 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v1_9,
    MDMQ.v1_10
  )

dtWorker$viz$MoodV01Pt06 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v1_11,
    MDMQ.v1_12,
    MDMQ.v1_13
  )

dtWorker$viz$MoodV02Pt01 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v2_1,
    MDMQ.v2_2
  )

dtWorker$viz$MoodV02Pt02 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v2_3,
    MDMQ.v2_4
  )

dtWorker$viz$MoodV02Pt03 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v2_5,
    MDMQ.v2_6
  )

dtWorker$viz$MoodV02Pt04 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v2_7,
    MDMQ.v2_8
  )

dtWorker$viz$MoodV02Pt05 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v2_9,
    MDMQ.v2_10
  )

dtWorker$viz$MoodV02Pt06 <- dtWorker$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    MDMQ.v2_11,
    MDMQ.v2_12,
    MDMQ.v2_13
  )
```

### Mean Plots  

We begin by plotting the item means of all variables. We always only display one to three variables jointly to improve visual inspection. We plot the means of the individual variables for each measurement occasion, summarizing the responses of all participants at any given time point. We additionally plot the data availability of each variable as a marginal plot above the main plot. The displayed time axis is the measurement index rather than the actual date to ensure comparability of the changes between each measurement. Plots with the raw date-time axis are saved and can be displayed if necessary.  

```{r workerMeanViz, echo=FALSE, results='hide',fig.keep='all'} 
dtWorker$vizPlotsMean <-
  lapply(seq_along(dtWorker$viz),
         function(i)
           statVarPlot(dataIn = dtWorker$viz[[i]], 
                       name = names(dtWorker$viz)[[i]], 
                       namList = varNameListWorker,
                       stat = "mean")
         )
dtWorker$vizPlotsMean
```

### SD Plots

To illustrate the developments of variance around the previously displayed means, we then plot the item standard deviations of all variables. We, thus, plot the average variation from the mean for each individual variable, again summarizing the responses of all participants at any given time point. We retain the same variable grouping, the data availability line plot, and the measurement index as the x axis.  

```{r WorkerSdViz, echo=FALSE, results='hide',fig.keep='all'} 
dtWorker$vizPlotsSd <-
  lapply(seq_along(dtWorker$viz),
         function(i)
           statVarPlot(dataIn = dtWorker$viz[[i]], 
                       name = names(dtWorker$viz)[[i]], 
                       namList = varNameListWorker,
                       stat = "sd")
         )
dtWorker$vizPlotsSd
```


## Study 2 (Student)

During the second study we collected the largest sample and additionally collected a range of motivations as well as pro-social and anti-social behaviors. 

We, again, select all potentially relevant variables and their labels, and then group the variables in small groups of one to three variables for plotting. 

```{r studentDataSelection}
varListStudent <- 
  c(
    "IntergroupContact",
    "InteractionDum",
    # "KeyNeedFullfillment",
    # "KeyNeedImp",
    "DaytimeNeedFullfillment",
    #"DaytimeNeedImportance",
    "InteractionNeedFullfillment",
    #"InteractionNeedImportance",
    "AntiSo1",
    "AntiSo2",
    "AntiSo3",
    "AntiSo4",
    "AntiSo5",
    "AntiSo6",
    "AntiSo7",
    "ProSo1",
    "ProSo2",
    "ProSo3",
    "ProSo4",
    "StudentGoal01",
    "StudentGoal02",
    "StudentGoal03",
    "StudentGoal04",
    "StudentGoal05",
    "StudentGoal06",
    "StudentGoal07",
    "StudentGoal08",
    "StudentGoal09",
    "StudentGoal10",
    "Autonomy",
    "Competence",
    # Break relatedness up into interaction vs. no interaction(?)
    # vars are already calculated
    "Relatedness",
    "AttitudesDutch",
    "AttitudesPartner",
    "ExWB",
    #"angry",
    #"afraid",
    #"energy",
    #"lonelyAlways",
    "Event"
  )

varNameListStudent <- 
  c(
    "IntergroupContact" = "Dutch Interaction",
    "InteractionDum" = "Any Interaction",
    # "KeyNeedFulfillment" = "Key Need Fulfillment",
    # "KeyNeedImp" = "Key Need Importance",
    "DaytimeNeedFullfillment" = "Daytime Core Motive Fulfillment",
    #"DaytimeNeedImportance" = "Daytime Core Motive Importance",
    "InteractionNeedFullfillment" = "Interaction Core Motive Fulfillment",
    #"InteractionNeedImportance" = "Interaction Core Motive Importance",
    "AntiSo1" = "Put someone down",
    "AntiSo2" = "Show little attention in someones opinion",
    "AntiSo3" = "Demeaning remarks",
    "AntiSo4" = "Inpropperly addressing someone",
    "AntiSo5" = "Ignored or excluded someone",
    "AntiSo6" = "Doubt someones judgement",
    "AntiSo7" = "Unwanted attempts of personal matters",
    "ProSo1" = "Listen to someones problems",
    "ProSo2" = "Cheer someone up",
    "ProSo3" = "Help someone get things done",
    "ProSo4" = "Help someone with responsibilities",
    "StudentGoal01" = "Social support and connectedness",
    "StudentGoal02" = "Romantic or sexual relationship",
    "StudentGoal03" = "Academic",
    "StudentGoal04" = "Career",
    "StudentGoal05" = "Financial",
    "StudentGoal06" = "Health and fitness",
    "StudentGoal07" = "Leasure and fun",
    "StudentGoal08" = "Personal improvement and growth",
    "StudentGoal09" = "Service and help",
    "StudentGoal10" = "Spiritual or religious",
    "Autonomy" = "Autonomy",
    "Competence" = "Competence",
    # Break relatedness up into interaction vs. no interaction(?)
    # vars are already calculated
    "Relatedness" = "Relatedness",
    "AttitudesDutch" = "Outgroup Attitude",
    "AttitudesPartner" = "Attitude Interaction Partner",
    "ExWB" = "Sadness Happiness",
    #"angry" = "Anger",
    #"afraid" = "Anxiety",
    #"energy" = "Energy",
    #"lonelyAlways" = "Loneliness",
    "Event" = "Positive or negative event present"
  )

dtStudents$viz <- list()

dtStudents$vizall <- dtStudents$full %>%
  select(
    PID,
    TID,
    TIDnum,
    all_of(varListStudent)
  )

dtStudents$viz$Interaction <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    IntergroupContact,
    InteractionDum
  )

dtStudents$viz$KeyNeed <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    DaytimeNeedFullfillment,
    InteractionNeedFullfillment
  )

dtStudents$viz$AntiSocialBehaviorPt1 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    AntiSo1,
    AntiSo2,
    AntiSo3
  )

dtStudents$viz$AntiSocialBehaviorPt2 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    AntiSo4,
    AntiSo5
  )

dtStudents$viz$AntiSocialBehaviorPt3 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    AntiSo6,
    AntiSo7
  )

dtStudents$viz$ProSocialBehaviorPt1 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    ProSo1,
    ProSo2
  )

dtStudents$viz$ProSocialBehaviorPt2 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    ProSo3,
    ProSo4
  )

dtStudents$viz$GoalsPt1 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal01,
    StudentGoal02
  )

dtStudents$viz$GoalsPt2 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal03,
    StudentGoal04
  )

dtStudents$viz$GoalsPt3 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal05,
    StudentGoal06
  )

dtStudents$viz$GoalsPt4 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal07,
    StudentGoal08
  )

dtStudents$viz$GoalsPt5 <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal09,
    StudentGoal10
  )

dtStudents$viz$SDT <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    Autonomy,
    Relatedness, 
    Competence
  )

dtStudents$viz$Attitudes <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    starts_with("Attitudes")
  )

dtStudents$viz$WB <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    ExWB
  )

dtStudents$viz$Event <- dtStudents$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    Event
  )

```

### Mean Plots

We again begin by plotting the item means of all variables. The plotting method is identical to that of Study 1. 

```{r studentMeanViz, echo=FALSE, results='hide',fig.keep='all'} 
dtStudents$vizPlotsMean <-
  lapply(seq_along(dtStudents$viz),
         function(i)
           statVarPlot(dataIn = dtStudents$viz[[i]], 
                       name = names(dtStudents$viz)[[i]], 
                       namList = varNameListStudent,
                       stat = "mean")
         )
dtStudents$vizPlotsMean
```

### SD Plots

We then also plot the average variation around the mean for each time point and variable. The plotting method is identical to that of Study 1. 

```{r studentSdViz, echo=FALSE, results='hide',fig.keep='all'} 
dtStudents$vizPlotsSd <-
  lapply(seq_along(dtStudents$viz),
         function(i)
           statVarPlot(dataIn = dtStudents$viz[[i]], 
                       name = names(dtStudents$viz)[[i]], 
                       namList = varNameListStudent,
                       stat = "sd")
         )
dtStudents$vizPlotsSd
```


## Study 3 (Medical)

The third study uses a similar set up as Study 2 but targets a more vulnerable sample (of young medical professionals). While most key variables are identical to Study 2, in this last study we additionally collected several cognitive evaluations (e.g., importance ratings) and emotional status measures (e.g., anger, nervousness, energy, and loneliness).

We, again, select all potentially relevant variables and their labels, and then group the variables in small groups of one to three variables for plotting. 

```{r medicalDataSelection}
varListMedical <- 
  c(
    "IntergroupContact",
    "InteractionDum",
    # "KeyNeedFulfillment",
    # "KeyNeedImp",
    "DaytimeNeedFullfillment",
    "DaytimeNeedImportance",
    "InteractionNeedFullfillment",
    "InteractionNeedImportance",
    "AntiSo1",
    "AntiSo2",
    "AntiSo3",
    "AntiSo4",
    "AntiSo5",
    "AntiSo6",
    "AntiSo7",
    "ProSo1",
    "ProSo2",
    "ProSo3",
    "ProSo4",
    "StudentGoal01",
    "StudentGoal02",
    "StudentGoal03",
    "StudentGoal04",
    "StudentGoal05",
    "StudentGoal06",
    "StudentGoal07",
    "StudentGoal08",
    "StudentGoal09",
    "StudentGoal10",
    "Autonomy",
    "Competence",
    # Break relatedness up into interaction vs. no interaction(?)
    # vars are already calculated
    "Relatedness",
    "AttitudesDutch",
    "AttitudesPartner",
    "exWB",
    "angry",
    "afraid",
    "energy",
    "lonelyAlways",
    "Event"
  )

varNameListMedical <- 
  c(
    "IntergroupContact" = "Dutch Interaction",
    "InteractionDum" = "Any Interaction",
    # "KeyNeedFulfillment" = "Key Need Fulfillment",
    # "KeyNeedImp" = "Key Need Importance",
    "DaytimeNeedFullfillment" = "Daytime Core Motive Fulfillment",
    "DaytimeNeedImportance" = "Daytime Core Motive Importance",
    "InteractionNeedFullfillment" = "Interaction Core Motive Fulfillment",
    "InteractionNeedImportance" = "Interaction Core Motive Importance",
    "AntiSo1" = "Put someone down",
    "AntiSo2" = "Show little attention in someones opinion",
    "AntiSo3" = "Demeaning remarks",
    "AntiSo4" = "Inpropperly addressing someone",
    "AntiSo5" = "Ignored or excluded someone",
    "AntiSo6" = "Doubt someones judgement",
    "AntiSo7" = "Unwanted attempts of personal matters",
    "ProSo1" = "Listen to someones problems",
    "ProSo2" = "Cheer someone up",
    "ProSo3" = "Help someone get things done",
    "ProSo4" = "Help someone with responsibilities",
    "StudentGoal01" = "Social support and connectedness",
    "StudentGoal02" = "Romantic or sexual relationship",
    "StudentGoal03" = "Academic",
    "StudentGoal04" = "Career",
    "StudentGoal05" = "Financial",
    "StudentGoal06" = "Health and fitness",
    "StudentGoal07" = "Leasure and fun",
    "StudentGoal08" = "Personal improvement and growth",
    "StudentGoal09" = "Service and help",
    "StudentGoal10" = "Spiritual or religious",
    "Autonomy" = "Autonomy",
    "Competence" = "Competence",
    # Break relatedness up into interaction vs. no interaction(?)
    # vars are already calculated
    "Relatedness" = "Relatedness",
    "AttitudesDutch" = "Outgroup Attitude",
    "AttitudesPartner" = "Attitude Interaction Partner",
    "exWB" = "Sadness Happiness",
    "angry" = "Anger",
    "afraid" = "Anxiety",
    "energy" = "Energy",
    "lonelyAlways" = "Loneliness",
    "Event" = "Positive or negative event present"
  )

dtMedical$viz <- list()

dtMedical$vizall <- dtMedical$full %>%
  select(
    PID,
    TID,
    TIDnum,
    all_of(varListMedical)
  )

dtMedical$viz$Interaction <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    IntergroupContact,
    InteractionDum
  )

dtMedical$viz$KeyNeedFulfillment <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    DaytimeNeedFullfillment,
    InteractionNeedFullfillment
  )

dtMedical$viz$KeyNeedImportance <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    DaytimeNeedImportance,
    InteractionNeedImportance
  )

dtMedical$viz$AntiSocialBehaviorPt1 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    AntiSo1,
    AntiSo2,
    AntiSo3
  )

dtMedical$viz$AntiSocialBehaviorPt2 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    AntiSo4,
    AntiSo5
  )

dtMedical$viz$AntiSocialBehaviorPt3 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    AntiSo6,
    AntiSo7
  )

dtMedical$viz$ProSocialBehaviorPt1 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    ProSo1,
    ProSo2
  )

dtMedical$viz$ProSocialBehaviorPt2 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    ProSo3,
    ProSo4
  )

dtMedical$viz$GoalsPt1 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal01,
    StudentGoal02
  )

dtMedical$viz$GoalsPt2 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal03,
    StudentGoal04
  )

dtMedical$viz$GoalsPt3 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal05,
    StudentGoal06
  )

dtMedical$viz$GoalsPt4 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal07,
    StudentGoal08
  )

dtMedical$viz$GoalsPt5 <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    StudentGoal09,
    StudentGoal10
  )

dtMedical$viz$SDT <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    Autonomy,
    Relatedness, 
    Competence
  )

dtMedical$viz$Attitudes <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    starts_with("Attitudes")
  )

dtMedical$viz$WB <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    exWB
  )

dtMedical$viz$Emotion <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    angry,
    afraid,
    energy,
    lonelyAlways
  )

dtMedical$viz$Event <- dtMedical$vizall %>%
  select(
    PID,
    TID,
    TIDnum,
    Event
  )

```

### Mean Plots

As with the previous studies, we begin by plotting the item means of all variables. The plotting method is identical to that of Studies 1 and 2.  

```{r medicalMeanViz, echo=FALSE, results='hide',fig.keep='all'} 
dtMedical$vizPlotsMean <-
  lapply(seq_along(dtMedical$viz),
         function(i)
           statVarPlot(dataIn = dtMedical$viz[[i]], 
                       name = names(dtMedical$viz)[[i]], 
                       namList = varNameListMedical,
                       stat = "mean")
         )
dtMedical$vizPlotsMean
```

### SD Plots

Lastly, also again plot the item standard deviations of all variables at each time point. The plotting procedures are again identical to Studies 1 and 2.  

```{r medicalSdViz, echo=FALSE, results='hide',fig.keep='all'} 
dtMedical$vizPlotsSd <-
  lapply(seq_along(dtMedical$viz),
         function(i)
           statVarPlot(dataIn = dtMedical$viz[[i]], 
                       name = names(dtMedical$viz)[[i]], 
                       namList = varNameListMedical,
                       stat = "sd")
         )
dtMedical$vizPlotsSd
```

</br>

--------------------------------------------------------------------

</br> 

# **Software Information**  
The full session information with all relevant system information and all loaded and installed packages is available in the collapsible section below.  

<details>
  <summary>System Info</summary>
  
  \renewcommand{\arraystretch}{0.8} <!-- decrease line spacing for the table -->
```{r Reproducibility-SessionInfo-R-environment, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", out.width='100%', results='asis'}
df_session_platform <- devtools::session_info()$platform %>%
  unlist(.) %>%
  as.data.frame(.) %>%
  rownames_to_column(.)

colnames(df_session_platform) <- c("Setting", "Value")

kbl(
  df_session_platform,
  booktabs = T,
  align = "l",
  caption = "R environment session info for reproducibility of results" # complete caption for main document
) %>%
  kable_classic(
    full_width = F,
    lightable_options = "hover",
    html_font = "Cambria"
  )
```
  \renewcommand{\arraystretch}{1} <!-- reset row height/line spacing -->
 </details>
 <br>
 <details>
  <summary>Package Info</summary>

\renewcommand{\arraystretch}{0.6} <!-- decrease line spacing for the table -->
```{r Reproducibility-SessionInfo-R-packages, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", out.width='100%', results='asis'}
df_session_packages <- devtools::session_info()$packages %>%
  as.data.frame(.) %>%
  filter(attached == TRUE) %>%
  dplyr::select(loadedversion, date, source) %>%
  rownames_to_column()

colnames(df_session_packages) <- c("Package", "Loaded version", "Date", "Source")

kbl(
  df_session_packages,
  booktabs = T,
  align = "l",
  caption = "Package info for reproducibility of results" # complete caption for main document
) %>%
  kable_classic(
    full_width = F,
    lightable_options = "hover",
    html_font = "Cambria"
  )
```
\renewcommand{\arraystretch}{1} <!-- reset row height/line spacing -->
</details>
<br>
<details>
  <summary>Full Session Info (including loaded but unattached packages --- for troubleshooting only)</summary>
    `r pander(sessionInfo(), compact = FALSE)`
</details>

</br>

--------------------------------------------------------------------

</br>  

<!-- # **References**   -->

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
