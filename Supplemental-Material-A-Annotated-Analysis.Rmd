---
title: "Supplemental Information A: Full Annotated Analysis and Reproducible Code"
subtitle: "Supplemental Material for 'Migration Trajectories [working title]'"
author:
- Jannis Kreienkamp^1,3^
- Kai Epstude^1,3^
- Laura F. Bringmann^1,3^
- Maximilian Agostini^1,3^
- Peter de Jonge^1,3^
- Rei Monden^2,3^
- ^1^University of Groningen, Department of Psychology
- ^2^Hiroshima University, Graduate School of Advanced Science and Engineering
- ^3^Author order TBD [currently in first name alphabetical order]
- "Author Information:"
- "Correspondence concerning this article should be addressed to Jannis Kreienkamp, Department of Psychology, University of Groningen, Grote Kruisstraat 2/1, 9712 TS Groningen (The Netherlands).  E-mail: j.kreienkamp@rug.nl"
- 'The main manuscript is available at <a href="https://www.doi.org/ToBePublished" target="_blank">doi.org/ToBePublished</a>'
- 'The data repository for this manuscript is available at <a href="https://osf.io/TBA" target="_blank">osf.io/TBA</a>'
- 'The GitHub repository for this manuscript is available at <a href="https://github.com/maskedForPeerReview" target="_blank">github.com/maskedForPeerReview</a>'
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::html_document2:
    fig_caption: yes
    md_extensions: +footnotes
    code_folding: hide
    mathjax: default
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: false
    css: style.css
    includes:
      in_header: "_includes/head-custom-rmd.html" 
editor_options:
  chunk_output_type: console
bibliography: references.bib
csl: apa.csl
header-includes:
   - \usepackage{amsmath, nccmath}
---

<style type="text/css">
.main-container {
  max-width: 1300px;
  margin-left: auto;
  margin-right: auto;
}
.table {
  margin-left:auto; 
  margin-right:auto;
}
</style>


```{r setup, include=FALSE}
# R Studio Clean-Up
cat("\014") # clear console
# rm(list=ls()) # clear workspace - use restart R instead [cmd/alt + shift + F10]
gc() # garbage collector

# Install and Load Packages
# !IMPORTANT!
# BEFORE FIRST RENDER:
# To install all relevant packages please run "renv::restore()" (or renv::init() and then initiate from lockfile) in the console before the first use to ensure that all packages are using the correct version.
# to store the packages in a contained library within the project folder: renv::settings$use.cache(FALSE) and add 'RENV_CONFIG_SANDBOX_ENABLED = FALSE' to an '.Renviron' file
lib <- c(
  "rmarkdown",
  "knitr",
  "remedy",
  "bookdown",
  "brms",
  "psych",
  "ggplot2",
  "ggthemes",
  "haven",
  "RColorBrewer",
  "plotly",
  "gridExtra",
  "ggpattern",
  "lme4",
  "nlme",
  "jtools",
  "gtsummary",
  "sessioninfo",
  "tibble",
  "pander",
  "devtools",
  "mada",
  "data.table",
  "plyr",
  "dplyr",
  "tidyr",
  "Hmisc",
  "kableExtra",
  "papaja",
  "stringr",
  "stringi",
  "reshape2",
  "lubridate",
  "purrr",
  "metafor",
  "dygraphs",
  "readxl", 
  "reshape",
  "factoextra"
)
invisible(lapply(lib, library, character.only = TRUE))
rm(lib)

# Load Custom Packages
source("./scripts/functions/fun.panel.R")
source("./scripts/functions/themes.R")
source("./scripts/functions/binaryCor.R")
source("./scripts/functions/MlCorMat.R")
source("./scripts/functions/MlTbl.R")
source("./scripts/functions/metaLmer.R")
source("./scripts/functions/meanViz.R")

# Markdown Options
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) # set working directory
knitr::opts_knit$get("root.dir") # check working directory
options(
  scipen = 999,
  digits = 4,
  width = 400
) # removes scientific quotation
# knitr::opts_chunk$set(echo = TRUE, cache = F, cache.path = rprojroot::find_rstudio_root_file('cache/')) # cache settings
knitr::knit_hooks$set(
  error = function(x, options) {
    paste('\n\n<div class="alert alert-danger">',
      gsub("##", "\n", gsub("^##\ Error", "**Error**", x)),
      "</div>",
      sep = "\n"
    )
  },
  warning = function(x, options) {
    paste('\n\n<div class="alert alert-warning">',
      gsub("##", "\n", gsub("^##\ Warning:", "**Warning**", x)),
      "</div>",
      sep = "\n"
    )
  },
  message = function(x, options) {
    paste('\n\n<div class="alert alert-info">',
      gsub("##", "\n", x),
      "</div>",
      sep = "\n"
    )
  }
)
htmltools::tagList(rmarkdown::html_dependency_font_awesome())

# Global Chunk Options
knitr::opts_chunk$set(
  fig.width = 12,
  fig.height = 8,
  fig.path = "Figures/",
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)
```

</br>

--------------------------------------------------------------------

</br> 

<i class="fas fa-exclamation-circle"></i> Note. Boxplots display the interquartile range (IQR, center box), and the whiskers extend 1.5*IQR from the lower and upper hinge. The white point indicates the mean and the white center line indicates the median.   

</br>

--------------------------------------------------------------------

</br> 


# **Data Preparation**  

In an initial preparatory step, we import the data into the R project environment and prepare the variables for further processing and later analyses.   

## Data Import  

The data were collected using two different survey tools. For the study with sojourners (Study 1: worker) we used the survey platform Qualtrics XM, whereas the studies with international students (Study 2: student), and the international medical professionals (Study 3: medical) were conducted using the survey framework FormR. This means that the datasets had inconsistent file formats and naming conventions. For the Qualtrics study we pre-processed some variables to ease the import process (for the syntax files see the SPS files in '_data/S1_Workers/processed/cleaned_' and for the raw data files see '_data/S1_Workers/raw_'). For the two other studies, we import the raw csv files from their respective folders.  

```{r formrImport}
# Load variable name lookup table
varNames <- readxl::read_excel("preregistration/varNames.xlsx")

# rename function
reNam <- function(data = NA, names = varNames, study = "S1", survey = "pre") {
  # for testing
  # data = dtS1$raw.pre
  # names = varNames
  # study = "S1"
  # survey = "pre"
  
  var <- paste0("survey", study)
  varNamOld <- paste0("varNam", study)
  
  nameTbl <- names %>%
    filter((!!sym(var)) == survey) %>%
    select(varNam, varNamOld = (!!sym(varNamOld)))
  
  data.table::setnames(data, as.character(nameTbl$varNamOld), as.character(nameTbl$varNam), skip_absent=TRUE)
  
  return(data)
}

# workers
# initial data cleaning was done in SPSS (syntax files are available in "")
dtS1 <- list(
  raw.pre = read_spss("data/S1_Workers/processed/cleaned/MT - Pre-Measure - 06-15-2018.sav") %>% 
    reNam(data = ., names = varNames, study = "S1", survey = "pre"),
  raw.post = read_spss("data/S1_Workers/processed/cleaned/MT - Post-Measure - 06-15-2018.sav") %>% 
    reNam(data = ., names = varNames, study = "S1", survey = "post"),
  raw.morning = read_spss("data/S1_Workers/processed/cleaned/MT - Morning - 06-15-2018.sav") %>% 
    reNam(data = ., names = varNames, study = "S1", survey = "daily"),
  raw.afternoon = read_spss("data/S1_Workers/processed/cleaned/MT - Afternoon - 06-15-2018.sav") %>% 
    reNam(data = ., names = varNames, study = "S1", survey = "daily")
)

# students
dtS2 <- list(
  raw.pre = read.csv(file = "data/S2_Students/raw/AOTS_Pre.csv", header = T, sep = ",") %>% 
    reNam(data = ., names = varNames, study = "S2", survey = "pre"),
  raw.post = read.csv(file = "data/S2_Students/raw/AOTS_Post.csv", header = T, sep = ",") %>% 
    reNam(data = ., names = varNames, study = "S2", survey = "post"),
  raw.daily = read.csv(file = "data/S2_Students/raw/AOTS_Daily.csv", header = T, sep = ",") %>% 
    reNam(data = ., names = varNames, study = "S2", survey = "daily")
)

# young medical professionals
dtS3 <- list(
  raw.eligibility = read.csv("data/S3_Medical/raw/AOTM_Eligibility.csv") %>% 
    reNam(data = ., names = varNames, study = "S3", survey = "pre_entry"), # works but should be 'survey = "pre_elig"'
  raw.pre = read.csv("data/S3_Medical/raw/AOTM_Pre.csv") %>% 
    reNam(data = ., names = varNames, study = "S3", survey = "pre_entry"),
  raw.post = read.csv("data/S3_Medical/raw/AOTM_Post.csv") %>% 
    reNam(data = ., names = varNames, study = "S3", survey = "post"),
  raw.daily = read.csv("data/S3_Medical/raw/AOTM_Daily.csv") %>% 
    reNam(data = ., names = varNames, study = "S3", survey = "daily")
)

# # FROM INITIAL VAR NAME EXPORT [LEGACY]
# # export var names
# S1Nam <- rbind(
#   data.frame(
#     study = "S1",
#     survey = "pre",
#     varNam = names(dtS1$raw.pre)
#   ),
#   data.frame(
#     study = "S1",
#     survey = "daily",
#     varNam = names(dtS1$raw.afternoon)
#   ),
#   data.frame(
#     study = "S1",
#     survey = "post",
#     varNam = names(dtS1$raw.post)
#   )
# )
# S2Nam <- rbind(
#   data.frame(
#     study = "S2",
#     survey = "pre",
#     varNam = names(dtS2$raw.pre)
#   ),
#   data.frame(
#     study = "S2",
#     survey = "daily",
#     varNam = names(dtS2$raw.daily)
#   ),
#   data.frame(
#     study = "S2",
#     survey = "post",
#     varNam = names(dtS2$raw.post)
#   )
# )
# S3Nam <- rbind(
#   data.frame(
#     study = "S3",
#     survey = "pre_elig",
#     varNam = names(dtS3$raw.eligibility)
#   ),
#   data.frame(
#     study = "S3",
#     survey = "pre_entry",
#     varNam = names(dtS3$raw.pre)
#   ),
#   data.frame(
#     study = "S3",
#     survey = "daily",
#     varNam = names(dtS3$raw.daily)
#   ),
#   data.frame(
#     study = "S3",
#     survey = "post",
#     varNam = names(dtS3$raw.post)
#   )
# )
# write.csv(
#   x = rbind(
#     S1Nam,
#     S2Nam,
#     S3Nam
#   ),
#   file = "preregistration/varNames.csv"
# )
```

## Data Cleaning & Data Exclusions  

### Study 1

For the sojourner sample data was collected in four separate surveys: (1) the pre-measurement, (2) the daily morning survey, (3) the daily afternoon survey, as well as (4) a post-measurement. We combine the four individual surveys into one cohesive dataframe and drop superfluous variables that are not relevant to the analyses relevant here. We then format the time and date variables and add person- and measurement indices (for easy and meaningful addressing of the data). We also exclude our own test data.  
<i class="fas fa-info-circle"></i> _Note:_ All data preparation steps are saved in the '_dtS1_' list. 

```{r cleanWorker}
# Create reduced data sets for morning and afternoon
dat.mo <- dtS1$raw.morning %>%
  select(-starts_with("t_"))
#setdiff(names(dtS1$raw.morning), names(dat.mo))
dat.mo$daytime <- "morning"

dat.af <- dtS1$raw.afternoon %>%
  select(-starts_with("t_"))
dat.af$daytime <- "afternoon"

# merge morning and afternoon measurements with indicator [+ clean up]
daily.dat <- plyr::rbind.fill(dat.mo, dat.af)
daily.dat <- daily.dat[daily.dat$last_outside_referrer != 55951, ]
dtS1$daily <- daily.dat
rm(dat.mo, dat.af, daily.dat)

# reduced data set for pre measurement
dat.pre.red <- dtS1$raw.pre %>%
  select(-starts_with("t_"))
names(dat.pre.red) <- paste(names(dat.pre.red), "pre", sep = ".")

# merge with daily data [+ clean up]
df.pre <- merge(
  x = dtS1$daily,
  y = dat.pre.red,
  by.x = "last_outside_referrer",
  by.y = "platformId.pre",
  all = T
)

# adjust duplicate names to fit to indicate daily or pre measurement
names(df.pre) <- gsub("[[:punct:]]x", ".daily", names(df.pre))
names(df.pre) <- gsub("[[:punct:]]y", ".pre", names(df.pre))

# reduced data set for post-measurement
dat.post.red <- dtS1$raw.post %>%
  select(-starts_with("t_"))
names(dat.post.red) <- paste(names(dat.post.red), "post", sep = ".")

# merge post measurement with pre- and daily data
df <- merge(
  x = df.pre,
  y = dat.post.red,
  by.x = "last_outside_referrer",
  by.y = "last_outside_referrer.post",
  all = T
)

# adjust duplicate names to indicate pre or post
names(df) <- gsub("[[:punct:]]x", ".pre", names(df))
names(df) <- gsub("[[:punct:]]y", ".post", names(df))

# add to list
dtS1$combined <- df
rm(df, df.pre, dat.post.red, dat.pre.red)

# create data frame with cleaned data
df <- dtS1$combined %>%
  filter(
    Finished.pre == 1,
    Finished == 1,
    !is.na(last_outside_referrer)
  )

# add running number as measurement ID within participants
df$measureID <- data.table::rowidv(df, cols = c("last_outside_referrer"))

dtS1$clean <- df

# clean up
rm(df)

# Export reduced Data
# write.csv(dtS1$clean, "data/processed/MT_clean-merged_07-05-2018.csv", row.names = F)
# save(dtS1$clean, file = "data/processed/MT_clean-merged_07-05-2018.RData")
```

### Study 2

For the student sample data was, similarly, collected in three separate surveys: (1) the pre-measurement, (2) the daily survey sent out at lunch and dinner time, and (3) a post-measurement. We combine the three individual surveys into one large dataframe and drop superfluous variables that are not relevant to the analyses relevant here. We exclude our own test data as well as one participant who entered the study twice (but gave different responses during the pre-measurement). We also reformat missing values and format core ID variables.  
<i class="fas fa-info-circle"></i> _Note:_ All data preparation steps are saved in the '_dtS2_' list. 

```{r cleanStudents}
# our own test IDs
ownIDs <- c(
  "beautifulLionfishXXXR5rcgVBzGu8hPvOqrK8UBJBw4owvi9nfRFSFu3lMzYhE",
  "niceDogoXXXmB8JI5SFu78SF3DVof84mGUPPNUr14p2HYFTtp31a6D1OwAzM6F-K",
  "amusedQuailXXXmhuc_fpTp8vPkMwDH1BzjaH1d1kHSO1bsPEfsnaEYk4WeVBfPi",
  "juwGAbtXX0_1kmZtSVqKh3PGaHOICqUyU4iBkrT3nDsI_uifuD1gzKcZerxaM5FL"
)

# Prepare dfs for Cleaning
df.pre <- dtS2$raw.pre %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!is.na(ended)) %>% # remove all who did not finish
  filter(!email %in% .$email[duplicated(.$email)]) %>% # remove all who did the pre questionnaire multiple times (b/c inconsistent ratings scales)
  filter(!ResponseId %in% ownIDs) %>% # remove our own test
  mutate(ResponseId = as.character(ResponseId)) # turn factor into character strings (probably just precaution)
names(df.pre) <- paste(names(df.pre), "pre", sep = ".")

df.post <- dtS2$raw.post %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!is.na(ResponseId)) %>% # remove own test runs
  filter(!ResponseId %in% ownIDs) %>% # remove our own test
  filter(ResponseId %in% df.pre$ResponseId) %>% # remove anyone who wasn't in the pre
  filter(!is.na(ended)) %>% # remove all who never finished
  filter(!ResponseId %in% .$ResponseId[duplicated(.$ResponseId)]) %>% # remove all duplicate ResponseIds
  mutate(ResponseId = as.character(ResponseId)) # turn factor into character strings (probably just precaution)
names(df.post) <- paste(names(df.post), "post", sep = ".")

df.daily <- dtS2$raw.daily %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!ResponseId %in% ownIDs) %>% # remove our own test
  filter(ResponseId %in% df.pre$ResponseId) %>% # remove anyone who wasn't in the pre
  filter(!is.na(ended)) %>% # remove all who never finished
  mutate(ResponseId = as.character(ResponseId)) # turn factor into character strings (probably just precaution)

# merge daily with pre
dfPreDaily <- merge(
  x = df.daily,
  y = df.pre,
  by.x = "ResponseId",
  by.y = "ResponseId.pre", 
  suffixes = c(".daily", ".pre"),
  all = FALSE
)

# merge daily with post
dfCombined <- merge(
  x = dfPreDaily,
  y = df.post,
  by.x = "ResponseId",
  by.y = "ResponseId.post", 
  suffixes = c(".pre", ".post"),
  all = FALSE
)

# add to list
dtS2$clean <- dfCombined

# clean up workspace
rm(df.pre, df.daily, df.post, dfPreDaily, dfCombined, ownIDs)
```


### Study 3

For the medical professionals sample data was, again, collected in three separate surveys: (1) the pre-measurement, (2) the daily survey sent out at lunch and dinner time, and (3) a post-measurement. We combine the three individual surveys into one large dataframe. We exclude our own test data. We also reformat missing values and format core ID variables.  
<i class="fas fa-info-circle"></i> _Note:_ All data preparation steps are saved in the '_dtS3_' list. 

```{r cleanMedical}
# our own test IDs
ownIDs <- c(
  "test_LeonieXXXSklxecPLW0-FBPM4796o3pUwUhAY5jb9KGw8jQsKxWmGpa1Jiy", 
  "test_MaxXXXtOp_5dTNefIq0yKXtXt2IN6eEKxeHoPY9mlyvdsqPpLp1B0NGg4UL",
  "test_JannisXXXBsNqk62fOpX6chbd2tMWPptUdjjnhAqnQ3uBqckZ7gLIEoPlfZ",
  "quaintLeopardCatXXXAJ9cfSj-_SZLwNwMDxv_xv_iyr1Bg5YFLTlYdrjW0UXZY",
  "blue-eyedIndianElephantXXXLf5zPMpQCDGS3umFzIj-YVky7ivTItvvozW49m"
)

# Prepare dfs for Cleaning
df.pre <- dtS3$raw.pre %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!is.na(ended)) %>% # remove all who did not finish
  filter(!ResponseId %in% ownIDs) %>% # remove our own test
  mutate(ResponseId = as.character(ResponseId)) # turn factor into character strings (probably just precaution)
names(df.pre) <- paste(names(df.pre), "pre", sep = ".")

df.post <- dtS3$raw.post %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>% 
  filter(!is.na(ResponseId)) %>% # remove own test runs
  filter(!ResponseId %in% ownIDs) %>% # remove our own test
  filter(ResponseId %in% df.pre$ResponseId) %>% # remove anyone who wasn't in the pre
  #filter(!is.na(ended)) %>% # remove all who never finished [disabled because only relevant if data is missing]
  filter(!ResponseId %in% .$ResponseId[duplicated(.$ResponseId)]) %>% # remove all duplicate ResponseIds
  mutate(ResponseId = as.character(ResponseId)) # turn factor into character strings (probably just precaution)
names(df.post) <- paste(names(df.post), "post", sep = ".")

df.daily <- dtS3$raw.daily %>%
  mutate_all(na_if, "") %>%
  mutate_all(na_if, "NA") %>%
  filter(!ResponseId %in% ownIDs) %>% # remove our own test
  filter(ResponseId %in% df.pre$ResponseId) %>% # remove anyone who wasn't in the pre
  #filter(!is.na(ended)) %>% # remove all who never finished [disabled because only relevant if data is missing]
  mutate(ResponseId = as.character(ResponseId)) # turn factor into character strings (probably just precaution)

# merge daily with pre
dfPreDaily <- merge(
  x = df.daily,
  y = df.pre,
  by.x = "ResponseId",
  by.y = "ResponseId.pre", 
  suffixes = c(".daily", ".pre"),
  all = F
)

# merge daily with post
dfCombined <- merge(
  x = dfPreDaily,
  y = df.post,
  by.x = "ResponseId",
  by.y = "ResponseId.post", 
  suffixes = c(".pre", ".post"),
  all = F
)

# add to list
dtS3$clean <- dfCombined

# clean up workspace
rm(df.pre, df.daily, df.post, dfPreDaily, dfCombined, ownIDs)
```


## Calculate needed transformations  

### Study 1

For the worker sample, the data transformation stage had three main aims: 

1. We first corrected time indicators within the surveys. In some cases participants completed their daily diary surveys for the afternoon after midnight. In these cases the measurement still is in reference to the previous day and is indicated in the corrected variable.   
2. We then created indices of scales. Some indices were multi-item scales while some indices combine equivalent measurement for different situational circumstances (e.g., competence perceptions after interactions and at measurement occasions without interactions).   
3. Finally, we calculated several basic participant summaries (averages across all measurement occasions).   

```{r newVarsWorkers}
df <- dtS1$clean

# Correct date_period ()
df <- df %>%
  mutate(
    startDate = as.Date(created),
    startTime = format(as.POSIXct(created), format = "%H:%M:%S")
  )
  
# order time
# df$TID <- factor(df$date_period, levels = unique(dtS3$raw.daily$date_period))
# df$TIDnum <- as.numeric(df$TID) # get numeric TID
df <- df %>%
  mutate(
    PID = as.numeric(factor(last_outside_referrer))
  )

# Time and Date Variables
df <- df %>%
  mutate(
    TID = measureID - 1,
    # time ID with t0 = 0 for meaningfull intercept interpretations
    date = substr(created, 1, 10),
    # awkward way of extracting date (best converted to )
    time = substr(created, 12, 19),
    # awkward way of extracting time
    daynum = as.numeric(factor(dateQualtrics)),
    # all days as numeric for ordering
    daycor = ifelse(
      daytime == "morning" &
        period_to_seconds(hms(time)) < period_to_seconds(hms("12:00:00")) |
        daytime == "afternoon" &
          period_to_seconds(hms(time)) < period_to_seconds(hms("19:00:00")),
      daynum - 1,
      daynum
    ),
    daycorTest = ifelse(
      daytime == "morning" &
        period_to_seconds(hms(time)) < period_to_seconds(hms("12:00:00")) |
        daytime == "afternoon" &
          period_to_seconds(hms(time)) < period_to_seconds(hms("19:00:00")),
      1,
      0
    ),
    # correctly identify which date the questionnaire is about
    daycor.lead = sprintf("%02d", daycor),
    daytime.lt = ifelse(daytime == "morning", "a", "b"),
    # morning / afternoon to a / b
    day_time = paste(daycor.lead, daytime.lt, sep = "_"),
    # combine day id with morning / afternoon
    ResponseId = as.numeric(factor(day_time)),
    # day and time identifier as numeric id
    SubTime = chron::times(time.0),
    time.daily = as.character(time),
    PPDate = as.Date(df$dateQualtrics),
    number = replace_na(ContactNum, 0),
    NonDutchNum = replace_na(NonDutchNum, 0)
  )

# remove seconds from afternoon time
df$SubTime[df$daytime == "afternoon"] <- paste0(substring(as.character(df$time.0[df$daytime == "afternoon"]), 4, 8), ":00")
df$time.daily[df$daytime == "afternoon" &
  !is.na(df$time.daily != "<NA>")] <- paste0(substring(as.character(df$time.daily[df$daytime == "afternoon" &
  !is.na(df$time.daily != "<NA>")]), 4, 8), ":00")

# Correct morning / afternoon date where survey was collected the day after to indicate the correct date that was targeted
df$PPDate[df$SubTime < "11:50:00" &
  df$daytime == "morning"] <- df$PPDate[df$SubTime < "11:50:00" &
  df$daytime == "morning"] - 1
df$PPDate[df$SubTime < "18:50:00" &
  df$daytime == "afternoon"] <- df$PPDate[df$SubTime < "18:50:00" &
  df$daytime == "afternoon"] - 1

# Make time IDs consistent with later studies
df$TID <- paste(df$PPDate, str_to_title(df$daytime))
df$TIDnum <- as.numeric(factor(df$TID %>% gsub(" Morning", "-A", .) %>% gsub(" Afternoon", "-B", .)))

df <- df %>%
  rowwise() %>%
  mutate(
    InteractionDum = sum(IntergroupContact, IngroupContact, na.rm = FALSE),
    InteractionDum = if_else(InteractionDum > 0, 1, InteractionDum),
    alertness = sum(alertness1, alertness2, na.rm = TRUE),
    calmness = sum(calmness1, calmness2, na.rm = TRUE),
    valence = sum(valence1, valence2, na.rm = TRUE)
  ) %>%
  ungroup()

# Need scales
df$keyMotiveFulfilled <- rowSums(df[, c("KeyNeedFulfillment", "DaytimeNeedFulfillment")], na.rm = T)
df$autonomy.daily.all <- rowSums(df[, c("autonomy_Int", "autonomy_NoInt")], na.rm = T)
df$competence.daily.all <- rowSums(df[, c("competence_Int", "competence_NoInt")], na.rm = T)
# cor(df$relatednessOther, df$relatedness_self_1,use="complete.obs")
df$relatedness.daily.all <- rowMeans(df[, c(
  "relatednessOther",
  "relatednessSelf",
  "relatednessNoInteraction"
)], na.rm = T)

pairs.panels.new(
  df[c("relatednessSelf", "relatednessOther")],
  labels = c(
    "I shared information about myself.",
    "X shared information about themselves."
  )
)
df$relatedness <- rowMeans(df[, c("relatednessOther", "relatednessSelf")], na.rm = T)

df$autonomy <- df$autonomy.daily.all
df$competence <- df$competence.daily.all
df$relatedness <- df$relatedness.daily.all

#
df <- df %>%
  mutate(
    exWB = scales::rescale(exWB, from = range(exWB, na.rm = TRUE), to = c(-100, 100)),
    relatedness = relatedness + 50,
    autonomy = autonomy + 50,
    competence = competence + 50,
    KeyNeedFulfillment = KeyNeedFulfillment + 50,
    KeyNeedDueToPartner = KeyNeedDueToPartner + 50,
    InteractionContextAccidental = InteractionContextAccidental + 50,
    InteractionContextvoluntary = InteractionContextvoluntary + 50,
    InteractionContextCooperative = InteractionContextCooperative + 50,
    InteractionContextRepresentativeNL = InteractionContextRepresentativeNL + 50,
    qualityOverall = qualityOverall + 50,
    qualityMeaning = qualityMeaning + 50,
    DaytimeNeedFulfillment = DaytimeNeedFulfillment + 50
  )
dtS1$full <- df
rm(df)
```

### Study 2

For the student sample, the data transformation stage had five main aims: 

1. We first create person, survey type, and measurement ID variables.   
2. We then created indices of scales. Some indices were multi-item scales while some indices combine equivalent measurement for different situational circumstances (e.g., competence perceptions after interactions and at measurement occasions without interactions).   
3. We add information about the interaction partner to the beep during which a person was selected as an interaction partner.   
4. We cluster mean-center key variables within participants.   
5. Finally, we calculated several basic participant summaries (averages across all measurement occasions).   

```{r newVarsStudents}
df <- dtS2$clean

# Add ID variables
df$PID <- as.numeric(factor(df$ResponseId)) # participant ID

# Correct date_period ()
df <- df %>%
  mutate(
    startDate = as.Date(created),
    startTime = format(as.POSIXct(created), format = "%H:%M:%S"),
    date_period_old = date_period,
    date_period = ifelse(
      startTime >= c("12:00") & startTime <= c("18:59"),
      paste(format(as.POSIXct(created), format = "%Y-%m-%d"), "Morning"),
      ifelse(
        startTime >= c("19:00") & startTime <= c("23:59"),
        paste(format(as.POSIXct(created), format = "%Y-%m-%d"), "Afternoon"),
        ifelse(
          startTime >= c("00:00") & startTime <= c("11:59"),
          paste(as.Date(created) - 1, "Afternoon"),
          NA
        )
      )
    )
  )
  
# order time
# df$TID <- factor(df$date_period, levels = unique(dtS3$raw.daily$date_period))
# df$TIDnum <- as.numeric(df$TID) # get numeric TID
df <- df %>%
  mutate(
    dateOrder = stri_replace_all_regex(
      date_period,
      pattern = c(' Morning', ' Afternoon'),
      replacement = c('_A', '_B'),
      vectorize = FALSE
    ),
    TID = factor(date_period),
    TIDnum = as.numeric(factor(dateOrder))
  )

# check whether time ordering worked
df <- df %>%
  arrange(PID, TID) 

# Interaction as Factor
df$interaction.f <-
  factor(df$Interaction,
    levels = c("no interaction", "Dutch", "Non-Dutch")
  )
df$intNL <- ifelse(df$Interaction == "Dutch", 1, 0)
df$intNonNL <- ifelse(df$Interaction == "Non-Dutch", 1, 0)

df$IntergroupContact <- (df$IntergroupContact-2)*-1

# -------------------------------------------------------------------------------------------------------------
#                                       Combine Variables
# -------------------------------------------------------------------------------------------------------------
# Relatedness
pairs.panels.new(
  df[c("relatednessSelf", "relatednessOther")],
  labels = c(
    "I shared information about myself.",
    "X shared information about themselves."
  )
)
df$relatednessInteraction <- rowMeans(df[c("relatednessSelf", "relatednessOther")], na.rm = TRUE)
df$relatednessInteraction[df$relatednessInteraction == "NaN"] <- NA
# Relatedness Overall (JANNIS NOT SURE THESE ARE CORRECT, CHANGE ROWS?; J: Changed "NaN" in df$RelatednessInteraction to NA() should work now)
df$relatedness <-
  rowMeans(df[, c("relatednessInteraction", "relatednessNoInteraction")],
           na.rm = TRUE) %>%
  ifelse(is.nan(.), NA, .)

# Core Need
df$DaytimeNeedFulfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFulfillment)] <-
  df$KeyNeedFulfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFulfillment)]

df$InteractionNeedFullfillment <- NA 
df$InteractionNeedFullfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFulfillment)] <- 
  df$KeyNeedFulfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFulfillment)]


# Randomly selected variables
df <- df %>%
  rowwise() %>%
  mutate(
    ProSo = mean(c(ProSo1, ProSo2, ProSo3, ProSo4), na.rm = TRUE),
    AntiSo = mean(c(AntiSo1, AntiSo2, AntiSo3, AntiSo4, AntiSo5, AntiSo6, AntiSo7), na.rm = TRUE)
  )

# -------------------------------------------------------------------------------------------------------------
#                                 Add Variables related to interaction partner
# -------------------------------------------------------------------------------------------------------------
# create function for later lapply
createIntPartDf <- function(inp) {
  # prepare the dataframe so that we can forloop over it later
  tmp <- data.frame(
    CC = as.character(inp$CC),
    NewCC = as.character(inp$NewCC),
    NewName = as.character(inp$NewName),
    NewCloseness = inp$NewCloseness,
    NewGender = inp$NewGender,
    NewEthnicity = as.character(inp$NewEthnicity),
    NewRelationship = as.character(inp$NewRelationship)
  )

  tmp$CC2 <- recode(tmp$CC, "SOMEONE ELSE" = "NA")
  tmp$CC2 <-
    ifelse(
      tmp$CC == 1 |
        tmp$CC == "SOMEONE ELSE",
      as.character(tmp$NewName),
      as.character(tmp$CC2)
    )
  # maybe add [[:space:]]\b to remove space before word boundary or ^[[:space:]] to remove space in the beginning of a string
  tmp$CC2 <- gsub("^[[:space:]]", "", tmp$CC2)
  tmp$NewName <- gsub("^[[:space:]]", "", tmp$NewName)

  # open the variables that will be filled up in the foor-loop
  tmp$closeness <- rep(NA, nrow(tmp))
  tmp$gender <- rep(NA, nrow(tmp))
  tmp$ethnicity <- rep(NA, nrow(tmp))
  tmp$relationship <- rep(NA, nrow(tmp))

  # Run the for-loop. It finds the variables related to the name of the interaction partner. If there is a repeating interaction
  # partner (i.e. CC2) it takes the value (i.e. NewCloseness) from the first interaction (i.e. NewName)
  for (i in 1:nrow(tmp)) {
    if (is.na(tmp$CC2[i])) {
      next
    } else {
      tmp$closeness[i] <-
        na.omit(tmp$NewCloseness[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # find closeness where CC2 matches NewName (na.omit + [1] to get the number)
      tmp$gender[i] <-
        na.omit(tmp$NewGender[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # (na.omit + [1] to get the number and not the rest of the na.omit list)
      tmp$ethnicity[i] <-
        na.omit(as.character(tmp$NewEthnicity[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1] # PROBLEM IS THAT THERE ARE TOO MANY NA's: Difficult to deal with
      tmp$relationship[i] <-
        na.omit(as.character(tmp$NewRelationship[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1]
    }
  }

  out <- tmp
  out
}

# split df per participants and run function
PP <- split(df, df$PID)
PP <- lapply(PP, createIntPartDf)
rm(createIntPartDf)

# add variables back to df
remergePP <- do.call(rbind.data.frame, PP)
colnames(remergePP) <-
  paste(colnames(remergePP), "_Calc", sep = "")
df <- cbind(df, remergePP)
rm(remergePP, PP)

dtS2$full <- df
rm(df)
```

### Study 3

For the medical professional sample, the data transformation stage had five main aims: 

1. We first create person, survey type, and measurement ID variables.   
2. We then created indices of scales. Some indices were multi-item scales while some indices combine equivalent measurement for different situational circumstances (e.g., competence perceptions after interactions and at measurement occasions without interactions).   
3. We cluster mean-center key variables within participants.   
4. Finally, we calculated several basic participant summaries (averages across all measurement occasions).   

```{r newVarsMedical}
df <- dtS3$clean

# Add ID variables
df$PID <- as.numeric(factor(df$ResponseId)) # participant ID

# Correct date_period ()
df <- df %>%
  mutate(
    startDate = as.Date(created),
    startTime = format(as.POSIXct(created), format = "%H:%M:%S"),
    date_period_old = date_period,
    date_period = ifelse(
      startTime >= c("12:00") & startTime <= c("18:59"),
      paste(format(as.POSIXct(created), format = "%Y-%m-%d"), "Morning"),
      ifelse(
        startTime >= c("19:00") & startTime <= c("23:59"),
        paste(format(as.POSIXct(created), format = "%Y-%m-%d"), "Afternoon"),
        ifelse(
          startTime >= c("00:00") & startTime <= c("11:59"),
          paste(as.Date(created) - 1, "Afternoon"),
          NA
        )
      )
    )
  )
  
# order time
# df$TID <- factor(df$date_period, levels = unique(dtS3$raw.daily$date_period))
# df$TIDnum <- as.numeric(df$TID) # get numeric TID
df <- df %>%
  mutate(
    dateOrder = stri_replace_all_regex(
      date_period,
      pattern = c(' Morning', ' Afternoon'),
      replacement = c('_A', '_B'),
      vectorize = FALSE
    ),
    TID = factor(date_period),
    TIDnum = as.numeric(factor(dateOrder))
  )

# check whether time ordering worked
df <- df %>%
  arrange(PID, TID)

# Interaction as Factor
df$interaction.f <-
  factor(df$Interaction,
    levels = c("no interaction", "Dutch", "Non-Dutch")
  )
df$intNL <- ifelse(df$Interaction == "Dutch", 1, 0)
df$intNonNL <- ifelse(df$Interaction == "Non-Dutch", 1, 0)

df <- df %>%
  mutate(
    NonDutchContact = replace_na(NonDutchNum, 0), # make second non-Dutch countable
    NonDutchContact = ifelse(NonDutchContact > 1, 1, 0) # recode (yes = 1 -> 1, no = 2 -> 0)
  ) %>%
  mutate(
    OutgroupInteraction = factor(
      InteractionDumDutch,
      levels = c(0, 1),
      labels = c("No", "Yes")
    ),
    NonOutgroupInteraction = factor(
      rowSums(select(., c(InteractionDumNonDutch, NonDutchContact)), na.rm = TRUE), # combine the two non-Dutch Q.,
      levels = c(0, 1),
      labels = c("No", "Yes")
    )
  )

df$IntergroupContact <- (df$IntergroupContact-2)*-1


# -------------------------------------------------------------------------------------------------------------
#                                       Combine Variables
# -------------------------------------------------------------------------------------------------------------
# Relatedness
pairs.panels.new(
  df[c("relatednessSelf", "relatednessOther")],
  labels = c(
    "I shared information about myself.",
    "X shared information about themselves."
  )
)
df$relatednessInteraction <-
  rowMeans(df[c("relatednessSelf", "relatednessOther")], na.rm = TRUE)
df$relatednessInteraction[df$relatednessInteraction == "NaN"] <- NA
# Relatedness Overall (JANNIS NOT SURE THESE ARE CORRECT, CHANGE ROWS?; J: Changed "NaN" in df$RelatednessInteraction to NA() should work now)
df$relatedness <-
  rowMeans(df[, c("relatednessInteraction", "relatednessNoInteraction")],
           na.rm = TRUE) %>%
  ifelse(is.nan(.), NA, .)


df$DaytimeNeedFulfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFulfillment)] <-
  df$KeyNeedFulfillment[df$InteractionDum == 0 & !is.na(df$KeyNeedFulfillment)]

df$InteractionNeedFullfillment <- NA 
df$InteractionNeedFullfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFulfillment)] <- 
  df$KeyNeedFulfillment[df$InteractionDum == 1 & !is.na(df$KeyNeedFulfillment)]

df$InteractionNeedImportance <- NA 
df$InteractionNeedImportance[df$InteractionDum == 1 & !is.na(df$KeyNeedImp)] <- 
  df$KeyNeedImp[df$InteractionDum == 1 & !is.na(df$KeyNeedImp)]


# Randomly selected variables
df <- df %>%
  rowwise() %>%
  mutate(
    ProSo = mean(c(ProSo1, ProSo2, ProSo3, ProSo4), na.rm = TRUE),
    AntiSo = mean(c(AntiSo1, AntiSo2, AntiSo3, AntiSo4, AntiSo5, AntiSo6, AntiSo7), na.rm = TRUE),
    agency = mean(c(agency1, agency2, agency3), na.rm = TRUE),
    autoFrust = mean(c(autoFrust1, autoFrust2, autoFrust3, autoFrust4), na.rm = TRUE),
    autoSat = mean(c(autoSat1, autoSat2, autoSat3, autoSat4), na.rm = TRUE),
    relatFrust = mean(c(relatFrust1, relatFrust2, relatFrust3, relatFrust4), na.rm = TRUE),
    relatSat = mean(c(relatSat1, relatSat2, relatSat3, relatSat4), na.rm = TRUE),
    compFrust = mean(c(compFrust1, compFrust2, compFrust3, compFrust4), na.rm = TRUE),
    compSat = mean(c(compSat1, compSat2, compSat3, compSat4), na.rm = TRUE),
    lonely = mean(c(lonely4, lonely4, lonely4, lonely4), na.rm = TRUE),
    emotRegPos = mean(c(emotRegPos01, emotRegPos02), na.rm = TRUE),
    emotRegNeg = mean(c(emotRegNeg01, emotRegNeg02), na.rm = TRUE)
  )


# Allport's Conditions
df %>%
  #filter(OutgroupInteraction == "Yes") %>%
  select(
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  ) %>%
  pairs.panels.new

AlportDescr <- df %>%
  #filter(OutgroupInteraction == "Yes") %>%
  select(
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  ) %>%
  psych::describe(., skew=F,ranges=T) %>%
  as.data.frame() %>%
  select(-vars) %>%
  kable(., caption = "Descriptives of Allport's Condition items") %>% 
  kable_styling("hover", full_width = F, latex_options = "hold_position")



iaWorkerAllport <- 
  df %>%
  #filter(OutgroupInteraction == "Yes") %>%
  select(
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  )

itemScaleAllport01 <- sjPlot::tab_itemscale(iaWorkerAllport)

pca <- parameters::principal_components(iaWorkerAllport)
factor.groups <- parameters::closest_component(pca)

sjPlot::tab_itemscale(iaWorkerAllport, factor.groups, show.kurtosis = TRUE)


AllportAlpha <- ltm::cronbach.alpha(na.omit(iaWorkerAllport), CI = TRUE)


data <- 
  df %>%
  select(
    PID,
    TIDnum,
    InteractionContextEqualStatus,
    KeyNeedShared,
    InteractionContextCooperative,
    InteractionContextvoluntary
  ) %>%
  drop_na %>%
  reshape2::melt(
    ., 
    id.vars = c("PID", "TIDnum")
  )

AllportNestedAlpha <- horst::nestedAlpha(item.level.1 = "value",
                   level.2      = "TIDnum",
                   level.3      = "PID",
                   data         = data)
rm(data)

iaWorkerAllportScale <- 
  iaWorkerAllport %>%
  Scale::Scale() %>%
  Scale::ItemAnalysis()

df$AllportsCondition <-
  scoreItems(
    keys = c(1, 1, 1, 1),
    items = df %>% select(
      InteractionContextEqualStatus,
      KeyNeedShared,
      InteractionContextCooperative,
      InteractionContextvoluntary
    ),
    min = 0,
    max = 100
  )$scores

as.data.frame(psych::describe(df$AllportsCondition, skew=T)) %>%
  mutate(vars = "Allport's Conditions Index") %>%
  kable(., caption = "Allport's Conditions: Scale Descriptives", row.names = FALSE) %>% 
  kable_styling("hover", full_width = F, latex_options = "hold_position")

ggplot(df, aes(x = AllportsCondition)) +
  geom_histogram() +
  theme_Publication()

# -------------------------------------------------------------------------------------------------------------
#                                 Add Variables related to interaction partner
# -------------------------------------------------------------------------------------------------------------
# create function for later lapply
createIntPartDf <- function(inp) {
  # prepare the dataframe so that we can forloop over it later
  tmp <- data.frame(
    CC = as.character(inp$CC),
    NewCC = as.character(inp$NewCC),
    NewName = as.character(inp$NewName),
    NewCloseness = inp$NewCloseness,
    NewGender = inp$NewGender,
    NewEthnicity = as.character(inp$NewEthnicity),
    NewRelationship = as.character(inp$NewRelationship)
  )

  tmp$CC2 <- recode(tmp$CC, "SOMEONE ELSE" = "NA")
  tmp$CC2 <-
    ifelse(
      tmp$CC == 1 |
        tmp$CC == "SOMEONE ELSE",
      as.character(tmp$NewName),
      as.character(tmp$CC2)
    )
  # maybe add [[:space:]]\b to remove space before word boundary or ^[[:space:]] to remove space in the beginning of a string
  tmp$CC2 <- gsub("^[[:space:]]", "", tmp$CC2)
  tmp$NewName <- gsub("^[[:space:]]", "", tmp$NewName)

  # open the variables that will be filled up in the foor-loop
  tmp$closeness <- rep(NA, nrow(tmp))
  tmp$gender <- rep(NA, nrow(tmp))
  tmp$ethnicity <- rep(NA, nrow(tmp))
  tmp$relationship <- rep(NA, nrow(tmp))

  # Run the for-loop. It finds the variables related to the name of the interaction partner. If there is a repeating interaction
  # partner (i.e. CC2) it takes the value (i.e. NewCloseness) from the first interaction (i.e. NewName)
  for (i in 1:nrow(tmp)) {
    if (is.na(tmp$CC2[i])) {
      next
    } else {
      tmp$closeness[i] <-
        na.omit(tmp$NewCloseness[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # find closeness where CC2 matches NewName (na.omit + [1] to get the number)
      tmp$gender[i] <-
        na.omit(tmp$NewGender[as.character(tmp$CC2[i]) == as.character(tmp$NewName)])[1] # (na.omit + [1] to get the number and not the rest of the na.omit list)
      tmp$ethnicity[i] <-
        na.omit(as.character(tmp$NewEthnicity[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1] # PROBLEM IS THAT THERE ARE TOO MANY NA's: Difficult to deal with
      tmp$relationship[i] <-
        na.omit(as.character(tmp$NewRelationship[as.character(tmp$CC2[i]) == as.character(tmp$NewName)]))[1]
    }
  }

  out <- tmp
  out
}

# split df per participants and run function
PP <- split(df, df$PID)
PP <- lapply(PP, createIntPartDf)
rm(createIntPartDf)

# add variables back to df
remergePP <- do.call(rbind.data.frame, PP)
colnames(remergePP) <-
  paste(colnames(remergePP), "_Calc", sep = "")
df <- cbind(df, remergePP)
rm(remergePP, PP)

dtS3$full <- df
```


## Data Availability and Sample Selection {.tabset .tabset-fade}

As one of our main analyses is a three-mode principal component analysis (3MPCA) we begin by assessing the amount of missing data in each of the ESM studies. To assess the missingness in detail, we prepare a data availability table of whether data is available or missing for each possible measurement point (data + morning/afternoon) for all individual participants. We then export the data availability tables as comma separated value files (.csv) to be assessed in detail using a spreadsheet program (such as MS Excel). 

For our sample selection we address both the selection of time points and participants. Given that multiple imputation procedures even work well with large proportions of missing data [assuming missingness at random; @Madley-Dowd2019], we decided on a general criterion of less than 45% missingness to balance sample size retention and bias in the multiple imputation model. Thus, we then select the time points for which we have less than 45% missingness and select participants who have less than 45% missingness across the selected time range.

To approximate an ideal sample selection that maximized the number of participants and timepoints that fit the 55% data availability criterion. We select sequentially remove the rows or columns with the lowest data availability rate untill all rows and columns have more than 55% data available (i.e., less than 45% missingness).

<div class="alert alert-info alert-dismissible fade in" role="alert">
  <a class="close" data-dismiss="alert" aria-label="close">&times;</a>
  <i class="fas fa-info-circle"></i> <b>Note: </b><br/>
  This needs to be adjusted current missingness criterion set to more conservative 33%.
</div>


### Study 1

```{r workerDataAvailability}
dtS1Availability <- dtS1$full %>%
  select(
    PID,
    TIDnum
  ) %>%
  arrange(PID, TIDnum) %>%
  mutate(data = 1)
dtS1Availability <- reshape::cast(dtS1Availability, PID ~ TIDnum) %>%
  select(-PID) %>%
  mutate_all(function(x) ifelse(x>1,1,x))
# sum(colMeans(dtS1Availability)*100 >= 66)
# sum(rowMeans(dtS1Availability)*100 >= 66)
# sum(colMeans(dtS1Availability[-5,])*100 >= 66)
# sum(rowMeans(dtS1Availability[,-8])*100 >= 66)

rownames(dtS1Availability) <- paste("PP", 1:nrow(dtS1Availability), sep = "_")
colnames(dtS1Availability) <- paste("t", 1:ncol(dtS1Availability), sep = "_")
dtS1AvailabilityKbl <- dtS1Availability

dtS1AvailabilityKbl[1:ncol(dtS1AvailabilityKbl)] <- lapply(dtS1AvailabilityKbl[1:ncol(dtS1AvailabilityKbl)], function(x) {
    cell_spec(x,
              bold = FALSE,
              color = "white",
              background = ifelse(x == 1, "green", "red")
              )
})
kbl(
  dtS1AvailabilityKbl,
  format = "html",
  escape = FALSE,
  align = "c",
  booktabs = TRUE,
  caption = "Study 1: Data Availability" # complete caption for main document
) %>%
  kable_classic(
    full_width = FALSE,
    lightable_options = "hover",
    html_font = "Cambria"
  ) %>%
  scroll_box(width = "100%", height = "500px")

write.csv(dtS1Availability, "data/S1_Workers/processed/workerAvailability.csv")
```


```{r testOptimizer, include=FALSE}
# set.seed(42)
# nr <- 5
# nc <- 10
# df <- as.data.table(matrix(rbinom(nr*nc,1,.66), nrow=nr, ncol=nc))
# df
# 
# best.list.row.df = list()
# for (i in 1:nrow(df)) {
#   # get best subset for rows based on how many columns have more than 66% data
#   rowlist = combn(nrow(df), i)
#   numobs = apply(rowlist, 2, function(x) sum(colMeans(df[x,])*100 >= 66))
#   cat("For subsets of", i, "rows, the highest number of observations is", max(numobs), "out of the", ncol(df), "maximum. Product =", i*max(numobs),"\n")
#   best = which(numobs == max(numobs))[1]
#   best.list.row.df = c(best.list.row.df, list(rowlist[, best]))
# }
# 
# best.list.col.df = list()
# for (i in 1:ncol(df)) {
#   # get best subset for columns based on how many rows have more than 66% data
#   collist = combn(ncol(df), i)
#   numobs = apply(collist, 2, function(x) sum(rowMeans(df[, ..x])*100 >= 66))
#   cat("For subsets of", i, "columns, the highest number of participants is", max(numobs), "out of the", nrow(df), "maximum. Product =", i*max(numobs),"\n")
#   best = which(numobs == max(numobs))[1]
#   best.list.col.df = c(best.list.col.df, list(collist[, best]))
# }
# rm(df, best.list.row.df, best.list.col.df)
```


```{r testOptimizer03, include=FALSE}
# library(dplyr)
# library(ROI)
# library(ROI.plugin.glpk)
# library(ompr)
# library(ompr.roi)
# 
# set.seed(42)
# tf <- matrix(sample(c(TRUE, FALSE), 1488, replace=TRUE), 31)
# M3 <- t(replicate(31, 1969:2016, simplify=TRUE))
# M3[tf] <- NA
# 
# m <- +!is.na(M3) # gets logical matrix; 0 if NA else 1    
# #m <- as.data.frame(dtS1AvailabilityTest)
# nr <- nrow(m)
# nc <- ncol(m)
# n_years <- 15 
# 
# 
# model <- MIPModel() %>% 
#   # keep[i,j] is 1 if matrix cell [i,j] is to be kept else 0
#   add_variable(keep[i,j], i = 1:nr, j = 1:nc, typ = "binary") %>% 
#   # rm_row[i] is 1 if row i is selected for removal else 0
#   add_variable(rm_row[i], i = 1:nr, type = "binary") %>% 
#   # rm_col[j] is 1 if column j is selected for removal else 0
#   add_variable(rm_col[j], j = 1:nc, type = "binary") %>% 
#   # maximize good cells kept
#   set_objective(sum_expr(keep[i,j], i = 1:nr, j = 1:nc), "max") %>% 
#   # cell can be kept only when row is not selected for removal
#   add_constraint(sum_expr(keep[i,j], j = 1:nc) <= 1 - rm_row[i], i = 1:nr) %>%
#   # cell can be kept only when column is not selected for removal
#   add_constraint(sum_expr(keep[i,j], i = 1:nr) <= 1 - rm_col[j], j = 1:nc) %>%
#   # keep at most n_years columns i.e. remove at least (nc - n_years) columns
#   # only non-NA values can be kept
#   add_constraint(m[i,j] + rm_row[i] + rm_col[j] >= 1, i = 1:nr, j = 1:nc) %>% 
#   #add_constraint(sum_expr(m[,j], j = 1:nc)/nc*100 >= 66) %>% 
#   #add_constraint(sum_expr(m[i,], i = 1:nr)/nr*100 >= 66) %>% 
#   # keep cols with more 
#   #add_constraint(colMeans(m[i,j], i = 1:nr, j = 1:nc) >= 0.66) %>%
#   # I used >= instead of == to avoid infeasiblity
#   #add_constraint(sum_expr(rm_col[j], j = 1:nc) >= nc - n_years) %>% 
#   # solve using free glpk solver
#   solve_model(with_ROI(solver = "glpk", verbose = TRUE))
# 
# solver_status(model)
# rm_rows <- model %>% 
#   get_solution(rm_row[i]) %>% 
#   filter(value > 0) %>% 
#   pull(i)
# 
# rm_cols <- model %>% 
#   get_solution(rm_col[j]) %>% 
#   filter(value > 0) %>% 
#   pull(j) 
# 
# result <- m[-rm_rows, -rm_cols, drop = F]
# result
```

```{r testOptimizer05}
cleanM <- function(M, c = 66) {
  check <- list()
  rowNamesOut <- c()
  colNamesOut <- c()
  for (i in 1:length(c(row.names(M), names(M)))) {
    rowMeans <- rowMeans(M) * 100
    colMeans <- colMeans(M) * 100
    rcMeans <- c(rowMeans, colMeans)
    rm <- which.min(rcMeans) %>% names
    rc <- ifelse(startsWith(rm, "PP_"), "row", "col")
    
    check[[i]] <- rcMeans
    
    if (!all(rcMeans >= c) && rc == "row") {
      M <- M[!(row.names(M) %in% rm), ]
      rowNamesOut <- append(rowNamesOut, rm)
      cat(i, ": Row ", rm, " had a completion rate of ", format(round(min(rcMeans), 2), nsmall = 2), "% and was removed.\n", sep = "")
    } else if (!all(rcMeans >= c) && rc == "col") {
      M <- M[, !(names(M) %in% rm)]
      colNamesOut <- append(colNamesOut, rm)
      cat(i, ": Column ", rm, " had a completion rate of ", format(round(min(rcMeans), 2), nsmall = 2), "% and was removed.\n", sep = "")
    } else {
      cat(i, ": All row- and column means are over ", c, "%. The final matrix has ", nrow(M), " rows and ", ncol(M), " columns.", sep = "")
      return(
        list(
          reducedMatrix = M,
          rowNamesIn = row.names(M),
          colNamesIn = names(M),
          rowNamesOut = rowNamesOut,
          colNamesOut = colNamesOut,
          rowMeans = rowMeans,
          colMeans = colMeans
        )
      )
    }
  }
}

dtS1RedInfo <- cleanM(M = as.data.frame(dtS1Availability), c = 66)

PIDout <- gsub("PP_", "", dtS1RedInfo$rowNamesOut) %>% as.numeric
TIDout <- gsub("t_", "", dtS1RedInfo$colNamesOut) %>% as.numeric
TIDInRed <- gsub("t_", "", dtS1RedInfo$colNamesIn) %>% as.numeric
TIDIn <- seq(min(TIDInRed), max(TIDInRed), 1)

dtS1Red <- dtS1$full %>%
  filter(
    !PID %in% PIDout,
    TIDnum %in% TIDIn
  ) %>% 
  mutate(TIDnum = TIDnum - min(TIDnum))
rm(PIDout, TIDout, TIDInRed, TIDIn)

# change glitch where survey was sent too early
dtS1Red$TIDnum[dtS1Red$PID == 7 & as.character(dtS1Red$created) == "2018-05-18 11:46:40"] <- 10
dtS1Red$TID[dtS1Red$PID == 7 & as.character(dtS1Red$created) == "2018-05-18 11:46:40"] <- "2018-05-18 Morning"

dtS1AvailabilityRedKbl <- dtS1RedInfo$reducedMatrix
dtS1AvailabilityRedKbl[1:ncol(dtS1AvailabilityRedKbl)] <- lapply(dtS1AvailabilityRedKbl[1:ncol(dtS1AvailabilityRedKbl)], function(x) {
    cell_spec(x,
              bold = FALSE,
              color = "white",
              background = ifelse(x == 1, "green", "red")
              )
})
kbl(
  dtS1AvailabilityRedKbl,
  format = "html",
  escape = FALSE,
  align = "c",
  booktabs = TRUE,
  caption = "Study 1: Final Data Availability" # complete caption for main document
) %>%
  kable_classic(
    full_width = FALSE,
    lightable_options = "hover",
    html_font = "Cambria"
  ) %>%
  scroll_box(width = "100%", height = "500px")
```


### Study 2

```{r studentDataAvailability}
dtS2Availability <- dtS2$full %>%
  select(
    PID,
    TIDnum
  ) %>%
  #na.omit %>%
  arrange(PID, TIDnum) %>%
  mutate(data = 1)
dtS2Availability <- reshape::cast(dtS2Availability, PID ~ TIDnum) %>%
  select(-PID)

rownames(dtS2Availability) <- paste("PP", 1:nrow(dtS2Availability), sep = "_")
colnames(dtS2Availability) <- paste("t", 1:ncol(dtS2Availability), sep = "_")

write.csv(dtS2Availability, "data/S2_Students/processed/studentAvailability.csv")

dtS2AvailabilityKbl <- dtS2Availability
dtS2AvailabilityKbl[1:ncol(dtS2AvailabilityKbl)] <- lapply(dtS2AvailabilityKbl[1:ncol(dtS2AvailabilityKbl)], function(x) {
    cell_spec(x,
              bold = FALSE,
              color = "white",
              background = ifelse(x == 1, "green", "red")
              )
})
kbl(
  dtS2AvailabilityKbl,
  format = "html",
  escape = FALSE,
  align = "c",
  booktabs = TRUE,
  caption = "Study 2: Data Availability" # complete caption for main document
) %>%
  kable_classic(
    full_width = FALSE,
    lightable_options = "hover",
    html_font = "Cambria"
  ) %>%
  scroll_box(width = "100%", height = "500px")
```

```{r s2SampleReduction}
dtS2RedInfo <- cleanM(M = as.data.frame(dtS2Availability), c = 66)

PIDout <- gsub("PP_", "", dtS2RedInfo$rowNamesOut) %>% as.numeric
TIDout <- gsub("t_", "", dtS2RedInfo$colNamesOut) %>% as.numeric
TIDInRed <- gsub("t_", "", dtS2RedInfo$colNamesIn) %>% as.numeric
TIDIn <- seq(min(TIDInRed), max(TIDInRed), 1)

dtS2Red <- dtS2$full %>%
  filter(
    !PID %in% PIDout,
    TIDnum %in% TIDIn
  ) %>% 
  mutate(TIDnum = TIDnum - min(TIDnum))
rm(PIDout, TIDout, TIDInRed, TIDIn)

# remove glitch entry 
dtS2Red <- dtS2Red[!(dtS2Red$PID == 46 & dtS2Red$TIDnum == 57 & dtS2Red$ended == "2018-12-20 21:58:31"),]

dtS2AvailabilityRedKbl <- dtS2RedInfo$reducedMatrix
dtS2AvailabilityRedKbl[1:ncol(dtS2AvailabilityRedKbl)] <- lapply(dtS2AvailabilityRedKbl[1:ncol(dtS2AvailabilityRedKbl)], function(x) {
    cell_spec(x,
              bold = FALSE,
              color = "white",
              background = ifelse(x == 1, "green", "red")
              )
})
kbl(
  dtS2AvailabilityRedKbl,
  format = "html",
  escape = FALSE,
  align = "c",
  booktabs = TRUE,
  caption = "Study 2: Final Data Availability" # complete caption for main document
) %>%
  kable_classic(
    full_width = FALSE,
    lightable_options = "hover",
    html_font = "Cambria"
  ) %>%
  scroll_box(width = "100%", height = "500px")
```

### Study 3

```{r medicalDataAvailability}
dtS3Availability <- dtS3$full %>%
  select(
    PID,
    TIDnum
  ) %>%
  arrange(PID, TIDnum) %>%
  mutate(data = 1)
dtS3Availability <- reshape::cast(dtS3Availability, PID ~ TIDnum, fill = 0) %>%
  select(-PID)

rownames(dtS3Availability) <- paste("PP", 1:nrow(dtS3Availability), sep = "_")
colnames(dtS3Availability) <- paste("t", 1:ncol(dtS3Availability), sep = "_")

write.csv(dtS3Availability, "data/S3_Medical/processed/medicalAvailability.csv")

dtS3AvailabilityKbl <- dtS3Availability
dtS3AvailabilityKbl[1:ncol(dtS3AvailabilityKbl)] <- lapply(dtS3AvailabilityKbl[1:ncol(dtS3AvailabilityKbl)], function(x) {
    cell_spec(x,
              bold = FALSE,
              color = "white",
              background = ifelse(x == 1, "green", "red")
              )
})
kbl(
  dtS3AvailabilityKbl,
  format = "html",
  escape = FALSE,
  align = "c",
  booktabs = TRUE,
  caption = "Study 2: Data Availability" # complete caption for main document
) %>%
  kable_classic(
    full_width = FALSE,
    lightable_options = "hover",
    html_font = "Cambria"
  ) %>%
  scroll_box(width = "100%", height = "500px")
rm(dtS3AvailabilityKbl)
```


```{r s3SampleReduction}
dtS3RedInfo <- cleanM(M = as.data.frame(dtS3Availability), c = 66)

PIDout <- gsub("PP_", "", dtS3RedInfo$rowNamesOut) %>% as.numeric
TIDout <- gsub("t_", "", dtS3RedInfo$colNamesOut) %>% as.numeric
TIDInRed <- gsub("t_", "", dtS3RedInfo$colNamesIn) %>% as.numeric
TIDIn <- seq(min(TIDInRed), max(TIDInRed), 1)

dtS3Red <- dtS3$full %>%
  filter(
    !PID %in% PIDout,
    TIDnum %in% TIDIn
  ) %>% 
  mutate(TIDnum = TIDnum - min(TIDnum))
rm(PIDout, TIDout, TIDInRed, TIDIn)

dtS3AvailabilityRedKbl <- dtS3RedInfo$reducedMatrix
dtS3AvailabilityRedKbl[1:ncol(dtS3AvailabilityRedKbl)] <- lapply(dtS3AvailabilityRedKbl[1:ncol(dtS3AvailabilityRedKbl)], function(x) {
    cell_spec(x,
              bold = FALSE,
              color = "white",
              background = ifelse(x == 1, "green", "red")
              )
})
kbl(
  dtS3AvailabilityRedKbl,
  format = "html",
  escape = FALSE,
  align = "c",
  booktabs = TRUE,
  caption = "Study 3: Final Data Availability" # complete caption for main document
) %>%
  kable_classic(
    full_width = FALSE,
    lightable_options = "hover",
    html_font = "Cambria"
  ) %>%
  scroll_box(width = "100%", height = "500px")
```


## Time Scales and Timepoint Aggregation


```{r checkVarAvailability}
varNamesPre <- varNames %>%
  filter(
    surveyS1 == "pre",
    surveyS2 == "pre",
    str_detect(surveyS3, "^pre")
  ) %>%
  select(varNam)
varNamesPreFull <-
  data.frame(varNam = Reduce(intersect, list(
    names(dtS1$full), names(dtS3$full), names(dtS3$full)
  ))) %>%
  filter(str_detect(varNam, ".pre$"))

varNamesDaily <- varNames %>%
  filter(
    surveyS1 == "daily",
    surveyS2 == "daily",
    surveyS3 == "daily"
  ) %>%
  select(varNam)
varNamesDailyFull <-
  data.frame(varNam = Reduce(intersect, list(
    names(dtS1Red), names(dtS2Red), names(dtS3Red)
  ))) %>%
  filter(!str_detect(varNam, ".pre$|.post$"))

varNamesPost <- varNames %>%
  filter(
    surveyS1 == "post",
    surveyS2 == "post",
    surveyS3 == "post"
  ) %>%
  select(varNam)
varNamesPostFull <-
  data.frame(varNam = Reduce(intersect, list(
    names(dtS1Red), names(dtS3Red), names(dtS3Red)
  ))) %>%
  filter(str_detect(varNam, ".post$"))
```

```{r analysisDFs}
# Main Analysis: 3MPCA (common variables across studies)
dropVarPcaMain <- c(
  # Meta Data
  "last_outside_referrer",
  "created",
  "ended",
  "ip_address",
  "date",
  "ResponseId",
  "server_language",
  "Meta_Browser",
  # Interaction Dummies (non-continuous)
  "IntergroupContact",
  "IngroupContact",
  "InteractionDum",
  # Interaction Counts (non-continuous)
  "ContactNum",
  "NonDutchNum",
  "groupDutch",
  # Interaction Descriptives (non-continuous)
  "duration",
  "dyadGroup",
  "groupSize",
  # Keyneed Freetexts (non-continuous)
  "KeyNeed",
  "DaytimeNeed",
  # Relatedness individual items
  "relatednessSelf",
  "relatednessOther",
  "relatednessNoInteraction"
)

varNam3mpcaMain <- varNamesDailyFull %>%
  filter(!varNam %in% dropVarPcaMain) %>%
  pull

dtMain3mpca <- rbind(
  dtS1Red %>% select(any_of(varNam3mpcaMain)) %>% mutate(study = "S1"),
  dtS3Red %>% select(any_of(varNam3mpcaMain)) %>% mutate(study = "S2"),
  dtS3Red %>% select(any_of(varNam3mpcaMain)) %>% mutate(study = "S3")
  ) %>%
  group_by(study, PID) %>%
  mutate(ID = cur_group_id()) %>%
  ungroup %>%
  mutate(
    date = as.Date(gsub(" .*", "", TID)),
    week = strftime(date, format = "%Y-W%V")
    ) %>%
  select(
    ID,
    PID,
    TID,
    date,
    week,
    TIDnum,
    study,
    everything()
  ) %>%
  arrange(ID, TIDnum)

dtMain3mpcaDaily <- dtMain3mpca %>%
  group_by(ID, date, study) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ungroup %>%
  group_by(study) %>%
  mutate(TIDnum = as.numeric(factor(date))) %>%
  ungroup %>%
  select(ID, date, TIDnum, everything()) %>%
  mutate_all(~ifelse(is.nan(.), NA, .))

dtMain3mpcaWeekly <- dtMain3mpca %>%
  group_by(ID, week, study) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ungroup %>%
  group_by(study) %>%
  mutate(TIDnum = as.numeric(factor(week))) %>%
  ungroup %>%
  select(ID, week, TIDnum, everything()) %>%
  mutate_all(~ifelse(is.nan(.), NA, .))
```


We aggregate the key variables over time to archive a reasonably interpretable number of time points and remove a first proportion of missing data. Given that little data is available on the meaningful time scales of the selected psychological variables, we chose to determine the appropriate time scales using variance decomposition [e.g., see @Ram2014]. This is to say that we create multi-level unconditional means models (without predictors) that include possible nested time scales as levels. We chose to select time scales that align with common human cycles. We thus compare the variances of bi-daily, daily, and weekly aggregations. Additional aggregations of two weeks or the full four weeks might be possible but would most likely reduce the variance too much for any meaningul further reduction during the 3MPCA.
We then chose the time scales that have the most variance.

```{r keyNeedTest}

# WILL USE IMPUTED DATA AND FOR-LOOP ACROSS ALL RELEVANT DVs
# PLOT EFFECT SIZES

dtMain3mpca <- dtMain3mpca %>%
  group_by(study) %>%
  mutate(
    TIDdate = as.numeric(factor(date)),
    TIDweek = as.numeric(factor(week))
  ) %>%
  ungroup

# Not sure whether TIDs as predictors or empty model?
keyNeedMlTest01 <-
  lme4::lmer(KeyNeedFulfillment ~ 1 + TIDnum + TIDdate + TIDweek + (1 + TIDnum + TIDdate + TIDweek | ID),
    data = dtMain3mpca
  ) 

keyNeedMlTest02 <-
  lme(
    KeyNeedFulfillment ~ 1 + TIDnum + TIDdate + TIDweek,
    random = ~ 1 + TIDnum + TIDdate + TIDweek | ID,
    data = dtMain3mpca %>% filter(!is.na(KeyNeedFulfillment)),
    control = list(opt = "nlmimb")
  ) # use optim if it does not converge

# summary(keyNeedMlTest02)
# summ(keyNeedMlTest01, digits = 3, center = FALSE)
# anova(keyNeedMlTest02)

```

## Multiple Imputation

We ultimately aim to create 20 imputed datasets to perform the analyses on. As outlined by @Monden2015, we will use the key variables themself as well as auxiliary variables to impute missing values. Auxiliary variables are any pre-, post-, or daily dairy variables other than the main variables. If there are any modeling issues we will limit the auxiliary variables to all variables that that are significantly ($p$ < .01) and meaningfully ($r$ > .3) correlated with (1) the key variables or (2) missingness on the key variables.

We create the imputed data set for each of the analyses. This includes the main analyses with across all three studies, using the set of common variables, as well as follow-up analyses for study-specific, interaction-specific and time scale specific datasets.


```{r varNames}
# varNames
varNamInS123 <- varNames %>%
  filter(
    pca != 0,
    surveyS1 == "daily",
    surveyS2 == "daily",
    surveyS3 == "daily"
  ) %>%
  select(varNam) %>%
  pull
varNamInS1 <- varNames %>%
  filter(
    pca != 0,
    surveyS1 == "daily"
  ) %>%
  select(varNam) %>%
  pull
varNamInS2 <- varNames %>%
  filter(
    pca != 0,
    surveyS2 == "daily"
  ) %>%
  select(varNam) %>%
  pull
varNamInS3 <- varNames %>%
  filter(
    pca != 0,
    surveyS3 == "daily"
  ) %>%
  select(varNam) %>%
  pull
varNamAdd <- c(
  "PID",
  "TID",
  "TIDnum",
  "relatedness",
  "autonomy",
  "competence"
)
varNamOut <- c(
  "ResponseId",
  "relatednessNoInteraction",
  "relatednessSelf",
  "relatednessOther",
  "autonomy_Int",
  "autonomy_NoInt",
  "competence_Int",
  "competence_NoInt",
  varNamInS1[grepl('^MDMQ', varNamInS1)],
  varNamInS2[grepl('^ProSo|^AntiSo', varNamInS2)],
  varNamInS3[grepl(
    '^ProSo|^AntiSo|^agency|^autoFrust|^autoSat|^relatFrust|^relatSat|^compFrust|^compSat|^lonely[0-9]|^emotRegPos|^emotRegNeg',
    varNamInS3
  )]
)
varNamNewS1 <- c(
  "alertness", 
  "calmness", 
  "valence"
)
varNamNewS2 <- c(
  "ProSo", 
  "AntiSo"
)
varNamNewS3 <- c(
  "ProSo", 
  "AntiSo",
  "agency",
  "autoFrust",
  "autoSat",
  "relatFrust",
  "relatSat",
  "compFrust",
  "compSat",
  "lonely",
  "emotRegPos",
  "emotRegNeg"
)
varNamIntDep <- c(
  varNamInS123[grepl('^InteractionContext|AttitudesPartner|KeyNeedDueToPartner|^quality', varNamInS123)]
)

varNamPcaS123 <- c(varNamAdd, varNamInS123[!varNamInS123 %in% varNamOut])
varNamPcaS123Indep <- varNamPcaS123[!varNamPcaS123 %in% varNamIntDep]
varNamPcaS1 <- c(varNamAdd, varNamNewS1, varNamInS1[!varNamInS1 %in% varNamOut])
varNamPcaS2 <- c(varNamAdd, varNamNewS2, varNamInS2[!varNamInS2 %in% varNamOut])
varNamPcaS3 <- c(varNamAdd, varNamNewS3, varNamInS3[!varNamInS3 %in% varNamOut])

idVars <- c("ID", "PID", "TID", "TIDnum", "date", "week", "study")
```

### Studies 1-3

We begin by preparing the data for the main analysis. Here, we: 

1. Select the variables for all relevant analysis (i.e., imputation, 3MPCA, and validation) across all three studies.
2. Create the combined dataset in the correct format (long format with all missed time points as NAs).
3. Impute the data and save the imputed datasets for later recall.


```{r MiMain3mpca}
library(Amelia)

varNamInMiMain <- varNames %>%
  filter(
    aux == 1,
    studyS1 == "S1",
    studyS2 == "S2",
    studyS3 == "S3"
  ) %>%
  select(varNam) %>%
  pull

varNamMiMain <- c(varNamAdd, varNamInMiMain[!varNamInMiMain %in% varNamOut])

varNamInMiMainPsbl <- c(
  paste(varNamMiMain, rep(".pre", length(varNamInMiMain)), sep = ""),
  varNamMiMain,
  paste(varNamMiMain, rep(".post", length(varNamInMiMain)), sep = "")
)

varNamInMiMainRed <- Reduce(
  intersect,
  list(
    dtS1Red %>% select(PID, TID, TIDnum, any_of(varNamInMiMainPsbl)) %>% names,
    dtS2Red %>% select(PID, TID, TIDnum, any_of(varNamInMiMainPsbl)) %>% names,
    dtS3Red %>% select(PID, TID, TIDnum, any_of(varNamInMiMainPsbl)) %>% names
  )
)

varNamMiMainNoms <- varNames %>%
  filter(
    aux == 1,
    format == "nominal",
    studyS1 == "S1",
    studyS2 == "S2",
    studyS3 == "S3"
  ) %>%
  select(varNam) %>%
  pull

dtMiMain <- rbind(
  dtS1Red %>% select(any_of(varNamInMiMainRed)) %>% mutate(study = "S1") %>% mutate(across(!TID &
                                                                                             !study, as.numeric)),
  dtS2Red %>% select(any_of(varNamInMiMainRed)) %>% mutate(study = "S2"),
  dtS3Red %>% select(any_of(varNamInMiMainRed)) %>% mutate(study = "S3")
) %>%
  group_by(study, PID) %>%
  mutate(ID = cur_group_id()) %>%
  ungroup %>%
  mutate(
    date = as.Date(gsub(" .*", "", TID)),
    week = strftime(date, format = "%Y-W%V"),
    roomate.pre = as.numeric(roomate.pre),
    Reason.pre = as.numeric(Reason.pre),
    association.pre = as.numeric(association.pre)
  ) %>%
  select(ID,
         study,
         date,
         week,
         everything(),
         -PID,
         -starts_with("ResponseId")) %>%
  as.data.frame %>%
  select_if(~ sum(!is.na(.)) > 1) %>% # only include variables that have any data (i.e., not all NA)
  complete(., ID, TIDnum) %>% # add na if id and TID combination is missing
  group_by(ID) %>%
  mutate(across(ends_with(c(".pre", ".post")),  ~ replace_na(.x, mean(.x, na.rm = TRUE)))) %>%
  mutate(study = replace_na(study, calc_mode(study))) %>%
  ungroup %>%
  group_by(study, TIDnum) %>%
  mutate(across(c("date", "week", "TID"),  ~ replace_na(.x, calc_mode(.x)))) %>%
  ungroup %>% 
  mutate(across(ends_with(c(".pre", ".post")), ~ ifelse(is.nan(.), NA, .))) %>%
  as.data.frame 

# MiMain <-
#   amelia(
#     dtMiMain,
#     m = 1, # 20
#     ts = "TIDnum",
#     cs = "ID",
#     idvars = c("TID", "date", "week", "study"), #"PID",
#     #lags = names(dtMiMain)[!names(dtMiMain) %in% idVars],
#     #lags = names(dtMiMain)[names(dtMiMain) %in%varNamInMiMainRed],
#     #noms = names(dtMiMain)[grepl(paste(varNamMiMainNoms, collapse = "|^"), names(dtMiMain))],
#     parallel = "multicore",
#     ncpus = parallel::detectCores(),
#     p2s = 1
#   )
# save(MiMain, file = "data/imputed/MainImputed.RData")
load("data/imputed/MainImputed.RData")
```

### Study 1

To be done once initial tests approved.

```{r MiS1}
varNamInMiS1 <- varNames %>%
  filter(
    aux == 1,
    studyS1 == "S1"
  ) %>%
  select(varNam) %>%
  pull

varNamMiS1 <- c(varNamAdd, varNamInMiS1[!varNamInMiS1 %in% varNamOut])

varNamInMiS1Psbl <- c(
  paste(varNamMiS1, rep(".pre", length(varNamMiS1)), sep = ""),
  varNamMiS1,
  paste(varNamMiS1, rep(".post", length(varNamMiS1)), sep = "")
)

varNamdtS1Noms <- varNames %>%
  filter(
    aux == 1,
    format == "nominal",
    studyS1 == "S1"
  ) %>%
  select(varNam) %>%
  pull

# TO BE ADAPTED:
dtMiS1 <- dtS1Red %>%
  mutate(
    date = as.Date(gsub(" .*", "", TID)),
    week = strftime(date, format = "%Y-W%V")
    ) %>%
  select(
    PID,
    TID,
    TIDnum,
    date,
    week,
    any_of(varNamInMiS1Psbl),
    -time,
    -starts_with("ResponseId")
  ) %>%
  as.data.frame %>%
  mutate_at(vars(-c("TID", "date", "week")), as.numeric) %>%
  select_if(~sum(!is.na(.)) > 1) %>% # only include variables that have any data (i.e., not all NA)
  select(PID,
         TID,
         TIDnum,
         date,
         week,
         which(sapply(., sd, na.rm = TRUE) > 0)) %>% # only include variables that vary (i.e., sd != 0)
  as.data.frame 


#dtS1MiCs <- names(dtMiS1)[endsWith(names(dtMiS1), c(".pre", ".post"))] # cross sectional vars

# MiS1 <-
#   amelia(
#     dtMiS1,
#     m = 1,
#     ts = "TIDnum",
#     cs = "PID",
#     idvars =  c("TID", "date", "week"),
#     #noms = names(dtMiS1)[grepl(paste(varNamdtS1Noms, collapse = "|^"), names(dtMiS1))],
#     #parallel = "multicore",
#     #ncpus = parallel::detectCores(),
#     p2s = 2
#   )
# save(MiS1, file = "data/imputed/S1Imputed.RData")
# load("data/imputed/S1Imputed.RData")
```

### Study 2

To be done once initial tests approved.

```{r MiS2}
# BASED ON MiS1
```

### Study 3

To be done once initial tests approved.

```{r MiS3}
# BASED ON MiS1
```


## Center and Normalize

For the 3MPCA, we center (across participants but within time point) and normalize (within variable but across time points) all key variables. The between-person centering, ensures that all variations are around the mean trend (which is removed by the centering). The normalization within variable are important for ensuring equal variances across variables, which ensures equal weighting of the variables in the 3MPCA.


```{r mainCentered}
varNam3mpcaMainAnalysis <- varNamesDailyFull %>%
  filter(!varNam %in% c(dropVarPcaMain, "PID", "TID", "TIDnum")) %>%
  pull

dtMain3mpcaNorm <-
  PCAnorm(data = dtMain3mpca,
          pid = "ID",
          tid = "TIDnum",
          selection = varNam3mpcaMainAnalysis)
```

## Long to Wide

For the Three-way ANOVA and the Three-mode PCA, the datasets need to be in a $n * mp$ matrix format, where $n$ is are the participants, $m$ are the time points, and $p$ are the variables. We do this by taking the prepared datasets, melting them into a id-variable-value table and casting the table into a wide format of variables_timepoint columns. 


```{r longToWide}
dtPcaS123 <- rbind(
  dtS1Red %>% select(any_of(varNamPcaS123)) %>% mutate(study = "S1"),
  dtS2Red %>% select(any_of(varNamPcaS123)) %>% mutate(study = "S2"),
  dtS3Red %>% select(any_of(varNamPcaS123)) %>% mutate(study = "S3")
  ) %>%
  group_by(study, PID) %>%
  mutate(ID = cur_group_id()) %>%
  ungroup %>%
  mutate(
    date = as.Date(gsub(" .*", "", TID)),
    week = strftime(date, format = "%Y-W%V")
    ) %>%
  select(
    ID,
    PID,
    TID,
    date,
    week,
    TIDnum,
    study,
    everything()
  ) %>%
  arrange(ID, TIDnum) %>% 
  filter(TIDnum <= min(max(dtS1Red$TIDnum), max(dtS2Red$TIDnum), max(dtS3Red$TIDnum)))

dtPcaS123Imp <- MiMain$imputations[[1]] %>% 
  select(ID, date, week, study, any_of(varNamPcaS123)) %>%
  arrange(ID, TIDnum) %>%
  filter(TIDnum <= min(max(dtS1Red$TIDnum), max(dtS2Red$TIDnum), max(dtS3Red$TIDnum)))

dtMainWideC <- PCAnorm(data = dtPcaS123,
          pid = "ID",
          tid = "TIDnum",
          selection = names(dtPcaS123)[!names(dtPcaS123) %in% idVars]) %>%
  select(
    ID,
    PID,
    TIDnum,
    study,
    ends_with("_gmc")
  ) %>%
  data.frame %>% 
  melt(
    .,
    id=c("ID", "PID", "TIDnum", "study")
  ) %>%
  mutate(
    variable = paste(gsub("_gmc", "", variable), stringr::str_pad(TIDnum, width = 2, pad = 0), sep = "_")
  ) %>%
  select(-TIDnum) %>%
  arrange(variable, ID) %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  replace(is.na(.), 0) %>%
  select(-ID, -PID, -study)
  #reshape(., idvar = "ID", timevar = "variable", direction = "wide") %>% View
  #pivot_wider(names_from = variable, values_from = value)

dtMainWide <- dtPcaS123 %>%
  select(
    -TID,
    -date,
    -week
  ) %>%
  data.frame %>% 
  melt(
    .,
    id=c("ID", "PID", "TIDnum", "study")
  ) %>%
  mutate(
    variable = paste(variable, stringr::str_pad(TIDnum, width = 2, pad = 0), sep = "_")
  ) %>%
  select(-TIDnum) %>%
  arrange(variable, ID) %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  replace(is.na(.), 0) %>%
  select(-ID, -PID, -study)

dtMainImpWide <- dtPcaS123Imp %>%
  select(
    -TID,
    -date,
    -week
  ) %>% 
  melt(
    .,
    id=c("ID", "TIDnum", "study")
  ) %>%
  mutate(
    variable = paste(variable, stringr::str_pad(TIDnum, width = 2, pad = 0), sep = "_")
  ) %>%
  select(-TIDnum, -study) %>%
  arrange(variable, ID) %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  #replace(is.na(.), 0) %>%
  select(-ID)

```


## Three-Way ANOVA

We assess the percentages of explained variance for the person-, variable-, and time aspects --- which offers an indication of whether a 3MPCA is useful for the dataset. Based on the grand mean centered variables we conduct a fixed-effects three-way ANOVA of the person-, variable-, and time modes as well as their various interactions. We are particularly interested in the highest order interaction term Person * Variable * Time + error, as a large amount of variance in this effect would speak towards the possible interdependence of the three modes.


```{r threeWayAnova, message=FALSE, warning=FALSE}
library(ThreeWay)
# threeWayAno <- threewayanova(
#   Y = dtMainWide,
#   n = nrow(dtMainWide), # Nr. ppt.s (A)
#   m = length(unique(dtPcaS123$TIDnum)), # Nr. time points (B)
#   #p = sum(!varNamPcaS123 %in% idVars) # Nr. variables (C)
#   p = length(names(dtPcaS123)[!names(dtPcaS123) %in% idVars]) # Nr. variables (C)
# )

capture.output(
  threeWayAnoImp <- threewayanova(
    Y = dtMainImpWide,
    n = nrow(dtMainImpWide), # Nr. ppt.s (A)
    m = length(unique(dtPcaS123Imp$TIDnum)), # Nr. time points (B)
    p = length(names(dtPcaS123Imp)[!names(dtPcaS123Imp) %in% idVars]) # Nr. variables (C)
  ), 
file='NUL')

options(knitr.kable.NA = '')
data.frame(SS = sapply(threeWayAnoImp, c)) %>%
  rownames_to_column(., var = "EffectNam") %>%
  mutate(RSqrd = SS / sum(SS) * 100) %>%
  add_row(
    EffectNam = "Total", 
    SS = sum(.$SS),
    RSqrd = NA
  ) %>%
  mutate(
    Effect = c(
      "Person",
      "Time",
      "Variable",
      "Person*Time",
      "Person*Variable",
      "Time*Variable",
      "Person*Time*Variable+error",
      "Total"
    )
  ) %>%
  select(Effect, everything(), -EffectNam) %>%
  kbl(.,
      escape = FALSE,
      booktabs = T,
      align = c("l", "r", "c"),
      digits=2,
      col.names = c(
        "Effect",
        "Sum of Squares",
        "$R^2$"
      ),
      caption = "Three-way ANOVA Main Analysis Single Imputation") %>%
  kable_classic(
    full_width = F,
    lightable_options = "hover",
    html_font = "Cambria"
  )

```

We find that the $Person*Time*Variable+error$ sums of squares are indeed the largest and speak towards the utility of a Three-Mode PCA. Interestingly, time itself has a relatively small percentage of explained variance and only becomes important in compination with person- or person- and variable-specific differences.  


```{r panel-setup, include = FALSE}
xaringanExtra::use_panelset()
xaringanExtra::style_panelset_tabs(font_family = "inherit")
```

# **Plots per Item** {.tabset .tabset-fade}

The three-mode PCA ultimately aims to explain the most variance with the fewest components (by maximizing the variance of data mapped in a lower dimensional space --- often by maximally separating groups of cases with similar variable patterns). Importantly, this procedure depends on variances and covariances to be present within the data. As one of our three modes is time and variance over time is not always given (e.g., because a variable is stable over the measured time span, such as personality over a month), it becomes important to assess whether a dimension reduction is possible for the variables measured during the measured time period. We, thus, start by visually inspecting the average changes and variance developments of all potentially relevant variables. We hope so see changes within the means and standard deviations over the measurement periods. 

Please note that the items might be measured on different ranges. To avoid misinterpretation of variances and changes over time, we cluster variables with similar ranges in different plots where necessary. 

## Means

To illustrate the developments of the means,we plot the item means of all variables. We plot the means of the individual variables for each measurement occasion, summarizing the responses of all participants at any given time point. The displayed time grouping is based on the measurement index rather than the actual date to ensure comparability of the changes between each measurement as well as studies. We plot the means for bi-daily, daily, and weekly timescales. 

### Studies 1-3 (Means) {.unlisted .unnumbered}

We beginn by assessing the imputed dataset of the main analysis, where participants from all three studies are combined, using the relevant variables that are available for all three studies.

```{r plotAllMean}
varClS123 <- dtPcaS123Imp %>%
  PCAnorm(data = .,
          pid = "ID",
          tid = "TIDnum",
          selection = names(.)[!names(.) %in% idVars]) %>%
  select(
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  summarise_all(
    sd, na.rm = TRUE
  ) %>%
  t %>% 
  as.data.frame %>%
  kmeans(., centers = 2)

PCAnorm(data = dtPcaS123Imp,
          pid = "ID",
          tid = "TIDnum",
          selection = names(dtPcaS123)[!names(dtPcaS123) %in% idVars]) %>% 
  select(
    ID,
    TIDnum,
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  melt(
    .,
    id=c("ID","TIDnum")
  ) %>%
  mutate(
    variable = gsub("_gmc", "", variable)
  ) %>%
  ggplot(., aes(x = variable, y = value, group = TIDnum, color = TIDnum)) +
  #geom_jitter() +
  stat_summary(fun=mean, geom="line") +
  labs(
    title = "Studies 1-3 Means over time [bi-daily]",
    y = "Grand Mean Centered Average",
    x = "Variable",
    color = "Timepoint",
    group = "Timepoint"
  ) +
  #coord_flip() +
  theme_Publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1),
    legend.key.size = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm'),
  )

dtPcaS123 %>%
  group_by(ID, date, study) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ungroup %>%
  group_by(study) %>%
  mutate(TIDnum = as.numeric(factor(date))) %>%
  ungroup %>%
  select(ID, date, TIDnum, everything()) %>%
  mutate_all(~ifelse(is.nan(.), NA, .)) %>%
  PCAnorm(data = .,
          pid = "ID",
          tid = "TIDnum",
          selection = names(.)[!names(.) %in% idVars]) %>% 
  select(
    ID,
    TIDnum,
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  melt(
    .,
    id=c("ID","TIDnum")
  ) %>%
  mutate(
    variable = gsub("_gmc", "", variable)
  ) %>%
  ggplot(., aes(x = variable, y = value, group = TIDnum, color = TIDnum)) +
  #geom_jitter() +
  stat_summary(fun=mean, geom="line") +
  labs(
    title = "Studies 1-3 Means over time [daily]",
    y = "Grand Mean Centered Average",
    x = "Variable",
    color = "Timepoint",
    group = "Timepoint"
  ) +
  #coord_flip() +
  theme_Publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1),
    legend.key.size = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm'),
  )

dtPcaS123 %>%
  group_by(ID, week, study) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ungroup %>%
  group_by(study) %>%
  mutate(TIDnum = as.numeric(factor(week))) %>%
  ungroup %>%
  select(ID, week, TIDnum, everything()) %>%
  mutate_all(~ifelse(is.nan(.), NA, .)) %>%
  PCAnorm(data = .,
          pid = "ID",
          tid = "TIDnum",
          selection = names(.)[!names(.) %in% idVars]) %>% 
  select(
    ID,
    TIDnum,
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  melt(
    .,
    id=c("ID","TIDnum")
  ) %>%
  mutate(
    variable = gsub("_gmc", "", variable)
  ) %>%
  ggplot(., aes(x = variable, y = value, group = TIDnum, color = TIDnum)) +
  #geom_jitter() +
  stat_summary(fun=mean, geom="line") +
  labs(
    title = "Studies 1-3 Means over time [weekly]",
    y = "Grand Mean Centered Average",
    x = "Variable",
    color = "Timepoint",
    group = "Timepoint"
  ) +
  #coord_flip() +
  theme_Publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1),
    legend.key.size = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm'),
  )
```

### Study 1 (Means) {.unlisted .unnumbered}

The first study, utilized not only the smallest sample but also a slightly different set of measured variables compared to the later two studies. Several variables are consistent across all three studies (e.g., types of social interactions, interaction needs, self-determiantion theory needs, outgroup attitudes, and experienced well-being). Study 1 additionally included several emotion and mood measurements but fewer cognitive and behavioral measures than studies two and three. 

```{r plotS1Mean, fig.height=16}
plotStat(
  dt = dtS1Red,
  varNams = varNamPcaS1,
  id = "PID",
  timescale = "bi-daily",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 1 Means over time [bi-daily]"
)

plotStat(
  dt = dtS1Red,
  varNams = varNamPcaS1,
  id = "PID",
  timescale = "daily",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 1 Means over time [daily]"
)

plotStat(
  dt = dtS1Red,
  varNams = varNamPcaS1,
  id = "PID",
  timescale = "weekly",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 1 Means over time [weekly]"
)
```

### Study 2 (Means) {.unlisted .unnumbered}

During the second study we collected the largest sample and additionally collected a range of motivations as well as pro-social and anti-social behaviors. 

We, again, select all potentially relevant variables and their labels, and then plot their developments on a bi-daily, daily, and weekly level. 

We again begin by plotting the item means of all variables. The plotting method is identical to that of Study 1. 

```{r plotS2Mean, fig.height=16}
plotStat(
  dt = dtS2Red,
  varNams = varNamPcaS2,
  id = "PID",
  timescale = "bi-daily",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 2 Means over time [bi-daily]"
)

plotStat(
  dt = dtS2Red,
  varNams = varNamPcaS2,
  id = "PID",
  timescale = "daily",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 2 Means over time [daily]"
)

plotStat(
  dt = dtS2Red,
  varNams = varNamPcaS2,
  id = "PID",
  timescale = "weekly",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 2 Means over time [weekly]"
)
```


### Study 3 (Means) {.unlisted .unnumbered}

The third study uses a similar set up as Study 2 but targets a more vulnerable sample (of young medical professionals). While most key variables are identical to Study 2, in this last study we additionally collected several cognitive evaluations (e.g., importance ratings) and emotional status measures (e.g., anger, nervousness, energy, and loneliness).

We, again, select all potentially relevant variables and their labels, and then plot their developments on a bi-daily, daily, and weekly level. 

As with the previous studies, we begin by plotting the item means of all variables. The plotting method is identical to that of Studies 1 and 2.  

```{r plotS3Mean, fig.height=16}
plotStat(
  dt = dtS3Red,
  varNams = varNamPcaS3,
  id = "PID",
  timescale = "bi-daily",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 3 Means over time [bi-daily]"
)

plotStat(
  dt = dtS3Red,
  varNams = varNamPcaS3,
  id = "PID",
  timescale = "daily",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 3 Means over time [daily]"
)

plotStat(
  dt = dtS3Red,
  varNams = varNamPcaS3,
  id = "PID",
  timescale = "weekly",
  clNum = 2,
  idVars = idVars,
  stat = "mean",
  title = "Study 3 Means over time [weekly]"
)
```



## SD

To illustrate the developments of variance around the means, we also plot the item standard deviations of all variables. We, thus, plot the average variation from the mean for each individual variable, again summarizing the responses of all participants at any given time point. We retain the same measurement indices as the x axis.  

### Studies 1-3 (SDs) {.unlisted .unnumbered}
<!-- <font size="5">Studies 1-3 (SDs)</font>  -->

```{r plotAllSd}
PCAnorm(data = dtPcaS123,
          pid = "ID",
          tid = "TIDnum",
          selection = names(dtPcaS123)[!names(dtPcaS123) %in% idVars]) %>% 
  select(
    ID,
    TIDnum,
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  melt(
    .,
    id=c("ID","TIDnum")
  ) %>%
  mutate(
    variable = gsub("_gmc", "", variable)
  ) %>%
  ggplot(., aes(x = variable, y = value, group = TIDnum, color = TIDnum)) +
  #geom_jitter() +
  stat_summary(fun=sd, geom="line") +
  labs(
    title = "Studies 1-3 SDs over time [bi-daily]",
    y = "Standard Deviation",
    x = "Variable",
    color = "Timepoint",
    group = "Timepoint"
  ) +
  #coord_flip() +
  theme_Publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1),
    legend.key.size = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm'),
  )

dtPcaS123 %>%
  group_by(ID, date, study) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ungroup %>%
  group_by(study) %>%
  mutate(TIDnum = as.numeric(factor(date))) %>%
  ungroup %>%
  select(ID, date, TIDnum, everything()) %>%
  mutate_all(~ifelse(is.nan(.), NA, .)) %>%
  PCAnorm(data = .,
          pid = "ID",
          tid = "TIDnum",
          selection = names(.)[!names(.) %in% idVars]) %>% 
  select(
    ID,
    TIDnum,
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  melt(
    .,
    id=c("ID","TIDnum")
  ) %>%
  mutate(
    variable = gsub("_gmc", "", variable)
  ) %>%
  ggplot(., aes(x = variable, y = value, group = TIDnum, color = TIDnum)) +
  #geom_jitter() +
  stat_summary(fun=sd, geom="line") +
  labs(
    title = "Studies 1-3 SDs over time [daily]",
    y = "Standard Deviation",
    x = "Variable",
    color = "Timepoint",
    group = "Timepoint"
  ) +
  #coord_flip() +
  theme_Publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1),
    legend.key.size = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm'),
  )

dtPcaS123 %>%
  group_by(ID, week, study) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE) %>%
  ungroup %>%
  group_by(study) %>%
  mutate(TIDnum = as.numeric(factor(week))) %>%
  ungroup %>%
  select(ID, week, TIDnum, everything()) %>%
  mutate_all(~ifelse(is.nan(.), NA, .)) %>%
  PCAnorm(data = .,
          pid = "ID",
          tid = "TIDnum",
          selection = names(.)[!names(.) %in% idVars]) %>% 
  select(
    ID,
    TIDnum,
    ends_with("_gmc")
  ) %>%
  data.frame %>%
  melt(
    .,
    id=c("ID","TIDnum")
  ) %>%
  mutate(
    variable = gsub("_gmc", "", variable)
  ) %>%
  ggplot(., aes(x = variable, y = value, group = TIDnum, color = TIDnum)) +
  #geom_jitter() +
  stat_summary(fun=sd, geom="line") +
  labs(
    title = "Studies 1-3 SDs over time [weekly]",
    y = "Standard Deviation",
    x = "Variable",
    color = "Timepoint",
    group = "Timepoint"
  ) +
  #coord_flip() +
  theme_Publication() +
  theme(
    axis.text.x = element_text(angle = 45, hjust=1),
    legend.key.size = unit(1, 'cm'),
    legend.key.height = unit(0.4, 'cm'),
  )
```

### Study 1 (SDs) {.unlisted .unnumbered}

```{r plotS1Sd, fig.height=16}
plotStat(
  dt = dtS1Red,
  varNams = varNamPcaS1,
  id = "PID",
  timescale = "bi-daily",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 1 SDs over time [bi-daily]"
)

plotStat(
  dt = dtS1Red,
  varNams = varNamPcaS1,
  id = "PID",
  timescale = "daily",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 1 SDs over time [daily]"
)

plotStat(
  dt = dtS1Red,
  varNams = varNamPcaS1,
  id = "PID",
  timescale = "weekly",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 1 SDs over time [weekly]"
)
```

### Study 2 (SDs) {.unlisted .unnumbered}

```{r plotS2Sd, fig.height=16}
plotStat(
  dt = dtS2Red,
  varNams = varNamPcaS2,
  id = "PID",
  timescale = "bi-daily",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 2 SDs over time [bi-daily]"
)

plotStat(
  dt = dtS2Red,
  varNams = varNamPcaS2,
  id = "PID",
  timescale = "daily",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 2 SDs over time [daily]"
)

plotStat(
  dt = dtS2Red,
  varNams = varNamPcaS2,
  id = "PID",
  timescale = "weekly",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 2 SDs over time [weekly]"
)
```


### Study 3 (SDs) {.unlisted .unnumbered}

```{r plotS3Sd, fig.height=16}
plotStat(
  dt = dtS3Red,
  varNams = varNamPcaS3,
  id = "PID",
  timescale = "bi-daily",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 3 SDs over time [bi-daily]"
)

plotStat(
  dt = dtS3Red,
  varNams = varNamPcaS3,
  id = "PID",
  timescale = "daily",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 3 SDs over time [daily]"
)

plotStat(
  dt = dtS3Red,
  varNams = varNamPcaS3,
  id = "PID",
  timescale = "weekly",
  clNum = 2,
  idVars = idVars,
  stat = "sd",
  title = "Study 3 SDs over time [weekly]"
)
```


</br>

--------------------------------------------------------------------

</br> 


# **Software Information**  
The full ResponseId information with all relevant system information and all loaded and installed packages is available in the collapsible section below.  

<details>
  <summary>System Info</summary>
  
  \renewcommand{\arraystretch}{0.8} <!-- decrease line spacing for the table -->
```{r Reproducibility-sessionInfo-R-environment, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", out.width='100%', results='asis'}
df_session_platform <- devtools::session_info()$platform %>%
  unlist(.) %>%
  as.data.frame(.) %>%
  rownames_to_column(.)

colnames(df_session_platform) <- c("Setting", "Value")

kbl(
  df_session_platform,
  booktabs = T,
  align = "l",
  caption = "R environment session info for reproducibility of results" # complete caption for main document
) %>%
  kable_classic(
    full_width = F,
    lightable_options = "hover",
    html_font = "Cambria"
  )
```
  \renewcommand{\arraystretch}{1} <!-- reset row height/line spacing -->
 </details>
 <br>
 <details>
  <summary>Package Info</summary>

\renewcommand{\arraystretch}{0.6} <!-- decrease line spacing for the table -->
```{r Reproducibility-sessionInfo-R-packages, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center", out.width='100%', results='asis'}
df_session_packages <- devtools::session_info()$packages %>%
  as.data.frame(.) %>%
  filter(attached == TRUE) %>%
  dplyr::select(loadedversion, date, source) %>%
  rownames_to_column()

colnames(df_session_packages) <- c("Package", "Loaded version", "Date", "Source")

kbl(
  df_session_packages,
  booktabs = T,
  align = "l",
  caption = "Package info for reproducibility of results" # complete caption for main document
) %>%
  kable_classic(
    full_width = F,
    lightable_options = "hover",
    html_font = "Cambria"
  )
```
\renewcommand{\arraystretch}{1} <!-- reset row height/line spacing -->
</details>
<br>
<details>
  <summary>Full Session Info (including loaded but unattached packages --- for troubleshooting only)</summary>
    `r pander(sessionInfo(), compact = FALSE)`
</details>

</br>

--------------------------------------------------------------------

</br>  

# **References**

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
